package org.itri.woundcamrtc.analytics;import android.content.Context;import android.content.res.AssetManager;import android.os.Build;import android.util.Log;import org.itri.woundcamrtc.AppResultReceiver;import org.itri.woundcamrtc.helper.FileHelper;import org.itri.woundcamrtc.helper.Model3DHelper;import org.opencv.core.CvType;import org.opencv.core.Mat;import org.opencv.core.MatOfPoint2f;import org.opencv.core.MatOfPoint3f;import org.opencv.core.Point;import org.opencv.core.Point3;import org.opencv.imgcodecs.Imgcodecs;import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;public class HomographyHelper {    private static String TAG = HomographyHelper.class.getSimpleName();    public static double[][] extrinsic3dCalibrationMatrixs = null;    public static double[][] extrinsic2dAlignementMatrixs4p = null; // 4P warpPerspective    public static double[][] extrinsic2dAlignementMatrixs3p = null; // 3P warpAffine    //https://blog.csdn.net/qq_27261889/article/details/80720359    public final static int MATRIX_WARP_TYPE_4P_WARPPERSPECTIVE = 6; //for Model3DHelper.mMatrixWarpType    public final static int MATRIX_WARP_TYPE_3P_WARPAFFINE = 10; //for Model3DHelper.mMatrixWarpType    public static void initCalibrationMatrixs(Context context) {        // CM type 1: extrinsic3dCalibrationMatrixs rgb2depth 1280x800 -> 1280x800        // CM type 2: extrinsic3dCalibrationMatrixs thm2depth 1280x800 -> 1280x800        //CM type 5~7 for warpPerspective        // CM type 5: extrinsic2dAlignementMatrixs4p rgb2depth  2448x3264 -> 1280x800        // CM type 6: extrinsic2dAlignementMatrixs4p thm2depth  120x160 -> 1280x800        // CM type 7: extrinsic2dAlignementMatrixs4p rgb2thm    2448x3264 -> 120x160        //CM type 9~11 for warpAffine        // CM type 9: extrinsic2dAlignementMatrixs rgb2depth  2448x3264 -> 1280x800        // CM type 10: extrinsic2dAlignementMatrixs thm2depth  120x160 -> 1280x800        // CM type 11: extrinsic2dAlignementMatrixs rgb2thm    2448x3264 -> 120x160        if (extrinsic3dCalibrationMatrixs != null)            return;        extrinsic3dCalibrationMatrixs = new double[8][13];        extrinsic2dAlignementMatrixs4p = new double[15][14];        extrinsic2dAlignementMatrixs3p = new double[8][13];        BufferedReader br = null;        String line = "";        String cvsSplitBy = ",";        int extrinsic3dCalibrationMatrixsCount = -1;        int extrinsic2dAlignementMatrixs4pCount = -1;        int extrinsic2dAlignementMatrixs3pCount = -1;        File file = null;        try {            //check /downloads/WoundcamRTC/config.csv            file = new File(AppResultReceiver.ROOT_FOLDER_PATH + "/config.csv");            if (file.exists() && file.canRead()) {                FileInputStream fileInputStream =                        new FileInputStream(file);                br = new BufferedReader(new InputStreamReader(fileInputStream));                while ((line = br.readLine()) != null) {                    line = line.trim();                    if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {                    } else {                        try {                            String[] data = line.split(cvsSplitBy);                            if (data[0].equals("CM")) {                                if (Double.valueOf(data[3]) > 0 && Double.valueOf(data[3]) < 4) {                                    extrinsic3dCalibrationMatrixsCount++;                                    if (extrinsic3dCalibrationMatrixsCount < 8) {                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][0] = Double.valueOf(data[1]); //SnapShut distance_lower                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][1] = Double.valueOf(data[2]); //SnapShut distance_upper                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][2] = Double.valueOf(data[3]); //matrix_type, 1=color3d, 2=thermal3D                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][3] = Double.valueOf(data[4]); //img_width                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][4] = Double.valueOf(data[5]); //img_height                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][5] = Double.valueOf(data[6]); //cx                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][6] = Double.valueOf(data[7]); //cy                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][7] = Double.valueOf(data[8]); //sx                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][8] = Double.valueOf(data[9]); //sy                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][9] = Double.valueOf(data[10]); //tx                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][10] = Double.valueOf(data[11]); //ty                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][11] = Double.valueOf(data[12]); //tz                                    }                                } else if (Double.valueOf(data[3]) > 4 && Double.valueOf(data[3]) < 8) {                                    extrinsic2dAlignementMatrixs4pCount++;                                    if (extrinsic2dAlignementMatrixs4pCount < 15) {                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][0] = Double.valueOf(data[1]); //SnapShut distance_lower                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][1] = Double.valueOf(data[2]); //SnapShut distance_upper                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][2] = Double.valueOf(data[3]); //matrix_type, 1=color3d, 2=thermal3D                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][3] = Double.valueOf(data[4]); //img_width                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][4] = Double.valueOf(data[5]); //img_height                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][5] = Double.valueOf(data[6]); //a1                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][6] = Double.valueOf(data[7]); //a2                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][7] = Double.valueOf(data[8]); //a3                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][8] = Double.valueOf(data[9]); //b1                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][9] = Double.valueOf(data[10]); //b2                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][10] = Double.valueOf(data[11]); //b3                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][11] = Double.valueOf(data[12]); //c1                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][12] = Double.valueOf(data[13]); //c2                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][13] = Double.valueOf(data[14]); //c3                                    }                                } else if (Double.valueOf(data[3]) > 8 && Double.valueOf(data[3]) < 12) {                                    extrinsic2dAlignementMatrixs3pCount++;                                    if (extrinsic2dAlignementMatrixs3pCount < 8) {                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][0] = Double.valueOf(data[1]); //SnapShut distance_lower                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][1] = Double.valueOf(data[2]); //SnapShut distance_upper                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][2] = Double.valueOf(data[3]); //matrix_type, 1=color3d, 2=thermal3D                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][3] = Double.valueOf(data[4]); //img_width                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][4] = Double.valueOf(data[5]); //img_height                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][5] = Double.valueOf(data[6]); //a11                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][6] = Double.valueOf(data[7]); //a12                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][7] = Double.valueOf(data[8]); //a13                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][8] = Double.valueOf(data[9]); //a21                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][9] = Double.valueOf(data[10]); //a22                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][10] = Double.valueOf(data[11]); //a23                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][11] = Double.valueOf(data[12]); //b11                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][12] = Double.valueOf(data[13]); //b21                                    }                                }                            }                        } catch (Exception ex) {                        }                    }                }            } else {                //file = new File("file:///android_asset/mldata/config.csv");                //if (file.exists() && file.canRead()) {                AssetManager assetManager = context.getAssets();                InputStream inputStream = assetManager.open("mldata/config.csv");                br = new BufferedReader(new InputStreamReader(inputStream));                while ((line = br.readLine()) != null) {                    line = line.trim();                    if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {                    } else {                        try {                            String[] data = line.split(cvsSplitBy);                            if (data[0].equals("CM")) {                                if (Double.valueOf(data[3]) > 0 && Double.valueOf(data[3]) < 4) {                                    extrinsic3dCalibrationMatrixsCount++;                                    if (extrinsic3dCalibrationMatrixsCount < 8) {                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][0] = Double.valueOf(data[1]);                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][1] = Double.valueOf(data[2]);                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][2] = Double.valueOf(data[3]);                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][3] = Double.valueOf(data[4]);                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][4] = Double.valueOf(data[5]);                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][5] = Double.valueOf(data[6]);                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][6] = Double.valueOf(data[7]);                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][7] = Double.valueOf(data[8]);                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][8] = Double.valueOf(data[9]);                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][9] = Double.valueOf(data[10]);                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][10] = Double.valueOf(data[11]);                                        extrinsic3dCalibrationMatrixs[extrinsic3dCalibrationMatrixsCount][11] = Double.valueOf(data[12]);                                    }                                } else if (Double.valueOf(data[3]) > 4 && Double.valueOf(data[3]) < 8) {                                    extrinsic2dAlignementMatrixs4pCount++;                                    if (extrinsic2dAlignementMatrixs4pCount < 8) {                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][0] = Double.valueOf(data[1]); //SnapShut distance_lower                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][1] = Double.valueOf(data[2]); //SnapShut distance_upper                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][2] = Double.valueOf(data[3]); //matrix_type, 1=color3d, 2=thermal3D                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][3] = Double.valueOf(data[4]); //img_width                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][4] = Double.valueOf(data[5]); //img_height                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][5] = Double.valueOf(data[6]); //a1                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][6] = Double.valueOf(data[7]); //a2                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][7] = Double.valueOf(data[8]); //a3                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][8] = Double.valueOf(data[9]); //b1                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][9] = Double.valueOf(data[10]); //b2                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][10] = Double.valueOf(data[11]); //b3                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][11] = Double.valueOf(data[12]); //c1                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][12] = Double.valueOf(data[13]); //c2                                        extrinsic2dAlignementMatrixs4p[extrinsic2dAlignementMatrixs4pCount][13] = Double.valueOf(data[14]); //c3                                    }                                } else if (Double.valueOf(data[3]) > 8 && Double.valueOf(data[3]) < 12) {                                    extrinsic2dAlignementMatrixs3pCount++;                                    if (extrinsic2dAlignementMatrixs3pCount < 8) {                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][0] = Double.valueOf(data[1]); //SnapShut distance_lower                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][1] = Double.valueOf(data[2]); //SnapShut distance_upper                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][2] = Double.valueOf(data[3]); //matrix_type, 1=color3d, 2=thermal3D                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][3] = Double.valueOf(data[4]); //img_width                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][4] = Double.valueOf(data[5]); //img_height                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][5] = Double.valueOf(data[6]); //a11                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][6] = Double.valueOf(data[7]); //a12                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][7] = Double.valueOf(data[8]); //a13                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][8] = Double.valueOf(data[9]); //a21                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][9] = Double.valueOf(data[10]); //a22                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][10] = Double.valueOf(data[11]); //a23                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][11] = Double.valueOf(data[12]); //b11                                        extrinsic2dAlignementMatrixs3p[extrinsic2dAlignementMatrixs3pCount][12] = Double.valueOf(data[13]); //b21                                    }                                }                            }                        } catch (Exception ex) {                        }                    }                }            }        } catch (Exception ex) {            extrinsic3dCalibrationMatrixs = null;            ex.printStackTrace();        } finally {            if (br != null) {                try {                    br.close();                } catch (Exception e) {                    e.printStackTrace();                }            }        }    }    public static Mat calculateRgb2ScreenHomography(Context context, int warpType) {        MatOfPoint2f dstRef = new MatOfPoint2f();        MatOfPoint2f srcRef = new MatOfPoint2f();        BufferedReader br = null;        String line = "";        String cvsSplitBy = ",";        int dataLineCount = 0;        File file = null;        try {            AssetManager assetManager = context.getAssets();            InputStream inputStream = assetManager.open("mldata/homography_rgb2scr_" + Build.MODEL.toLowerCase().replace(" ", "_") + ".csv");            br = new BufferedReader(new InputStreamReader(inputStream));            while ((line = br.readLine()) != null) {                line = line.trim();                if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {                } else {                    dataLineCount++;                    String[] data = line.split(cvsSplitBy);                    srcRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[0]), Integer.valueOf(data[1]))));                    dstRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[2]), Integer.valueOf(data[3]))));                }            }        } catch (Exception ex) {            ex.printStackTrace();        } finally {            if (br != null) {                try {                    br.close();                } catch (Exception e) {                    e.printStackTrace();                }            }        }////        if (dataLineCount < 8) {//            //ref from Mi 8T//            srcRef.release();//            srcRef = new MatOfPoint2f();//            dstRef.release();//            dstRef = new MatOfPoint2f();//            srcRef.push_back(new MatOfPoint2f(new Point(83, 40)));//            srcRef.push_back(new MatOfPoint2f(new Point(571, 31)));//            srcRef.push_back(new MatOfPoint2f(new Point(575, 329)));//            srcRef.push_back(new MatOfPoint2f(new Point(79, 320)));//            dstRef.push_back(new MatOfPoint2f(new Point(2376, 520)));//            dstRef.push_back(new MatOfPoint2f(new Point(2424, 3584)));//            dstRef.push_back(new MatOfPoint2f(new Point(576, 3600)));//            dstRef.push_back(new MatOfPoint2f(new Point(624, 520)));//            dataLineCount = 8;//        }        Mat tempMat = new Mat();        Mat outputMat = null;        int configCmType = 0;        if (warpType == HomographyHelper.MATRIX_WARP_TYPE_4P_WARPPERSPECTIVE) {            outputMat = org.opencv.calib3d.Calib3d.findHomography(srcRef, dstRef, org.opencv.calib3d.Calib3d.RANSAC, 2000, tempMat);            configCmType = 4;        } else {            outputMat = org.opencv.calib3d.Calib3d.estimateAffine2D(srcRef, dstRef);            configCmType = 8;        }        Log.i(TAG, "Transform matrix: " + outputMat.dump());        printMat("rgb2scr " + configCmType, outputMat);        return outputMat;    }    public static Mat calculateAligmentRgb2DepthHomography(Context context, int warpType) {        //type 5        MatOfPoint2f dstRef = new MatOfPoint2f();        MatOfPoint2f srcRef = new MatOfPoint2f();        BufferedReader br = null;        String line = "";        String cvsSplitBy = ",";        int dataLineCount = 0;//        File file = null;        try {//            file = new File("file:////android_asset/mldata/alignement_" + Build.MODEL.toLowerCase().replace(" ", "_") + ".csv");//            if (file.exists() && file.canRead()) {            AssetManager assetManager = context.getAssets();            InputStream inputStream = assetManager.open("mldata/alignement_rgb2depth_" + Build.MODEL.toLowerCase().replace(" ", "_") + ".csv");            br = new BufferedReader(new InputStreamReader(inputStream));            while ((line = br.readLine()) != null) {                line = line.trim();                if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {                } else {                    dataLineCount++;                    String[] data = line.split(cvsSplitBy);                    srcRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[0]), Integer.valueOf(data[1]))));                    dstRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[2]), Integer.valueOf(data[3]))));                }            }//            }        } catch (Exception ex) {            ex.printStackTrace();        } finally {            if (br != null) {                try {                    br.close();                } catch (Exception e) {                    e.printStackTrace();                }            }        }        Mat tempMat = new Mat();        Mat outputMat = null;        int configCmType = 0;        if (warpType == HomographyHelper.MATRIX_WARP_TYPE_4P_WARPPERSPECTIVE) {            outputMat = org.opencv.calib3d.Calib3d.findHomography(srcRef, dstRef, org.opencv.calib3d.Calib3d.RANSAC, 2000, tempMat);            configCmType = 5;        } else {            outputMat = org.opencv.calib3d.Calib3d.estimateAffine2D(srcRef, dstRef);            configCmType = 9;        }        Log.i(TAG, "Transform matrix: " + outputMat.dump());        printMat("rgb2depth " + configCmType, outputMat);        return outputMat;    }    public static Mat calculateAligmentThm2DepthHomography(Context context, int warpType) {        //type 6        MatOfPoint2f dstRef = new MatOfPoint2f();        MatOfPoint2f srcRef = new MatOfPoint2f();        BufferedReader br = null;        String line = "";        String cvsSplitBy = ",";        int dataLineCount = 0;//        File file = null;        try {//            file = new File("file:////android_asset/mldata/alignement_" + Build.MODEL.toLowerCase().replace(" ", "_") + ".csv");//            if (file.exists() && file.canRead()) {            AssetManager assetManager = context.getAssets();            InputStream inputStream = assetManager.open("mldata/alignement_thm2depth_" + Build.MODEL.toLowerCase().replace(" ", "_") + ".csv");            br = new BufferedReader(new InputStreamReader(inputStream));            while ((line = br.readLine()) != null) {                line = line.trim();                if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {                } else {                    dataLineCount++;                    String[] data = line.split(cvsSplitBy);                    srcRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[0]), Integer.valueOf(data[1]))));                    dstRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[2]), Integer.valueOf(data[3]))));                }            }//            }        } catch (Exception ex) {            ex.printStackTrace();        } finally {            if (br != null) {                try {                    br.close();                } catch (Exception e) {                    e.printStackTrace();                }            }        }        Mat tempMat = new Mat();        Mat outputMat = null;        int configCmType = 0;        if (warpType == HomographyHelper.MATRIX_WARP_TYPE_4P_WARPPERSPECTIVE) {            outputMat = org.opencv.calib3d.Calib3d.findHomography(srcRef, dstRef, org.opencv.calib3d.Calib3d.RANSAC, 2000, tempMat);            configCmType = 6;        } else {            outputMat = org.opencv.calib3d.Calib3d.estimateAffine2D(srcRef, dstRef);            configCmType = 10;        }        Log.i(TAG, "Transform matrix: " + outputMat.dump());        printMat("thm2depth " + configCmType, outputMat);        return outputMat;    }    public static Mat calculateAligmentRgb2ThmHomography(Context context, int warpType) {        //type 7        MatOfPoint2f dstRef = new MatOfPoint2f();        MatOfPoint2f srcRef = new MatOfPoint2f();        BufferedReader br = null;        String line = "";        String cvsSplitBy = ",";        int dataLineCount = 0;//        File file = null;        try {//            file = new File("file:////android_asset/mldata/alignement_" + Build.MODEL.toLowerCase().replace(" ", "_") + ".csv");//            if (file.exists() && file.canRead()) {            AssetManager assetManager = context.getAssets();            InputStream inputStream = assetManager.open("mldata/alignement_rgb2thm_" + Build.MODEL.toLowerCase().replace(" ", "_") + ".csv");            br = new BufferedReader(new InputStreamReader(inputStream));            while ((line = br.readLine()) != null) {                line = line.trim();                if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {                } else {                    dataLineCount++;                    String[] data = line.split(cvsSplitBy);                    srcRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[0]), Integer.valueOf(data[1]))));                    dstRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[2]), Integer.valueOf(data[3]))));                }            }//            }        } catch (Exception ex) {            ex.printStackTrace();        } finally {            if (br != null) {                try {                    br.close();                } catch (Exception e) {                    e.printStackTrace();                }            }        }        Mat tempMat = new Mat();        Mat outputMat = null;        int configCmType = 0;        if (warpType == HomographyHelper.MATRIX_WARP_TYPE_4P_WARPPERSPECTIVE) {            outputMat = org.opencv.calib3d.Calib3d.findHomography(srcRef, dstRef, org.opencv.calib3d.Calib3d.RANSAC, 2000, tempMat);            configCmType = 7;        } else {            outputMat = org.opencv.calib3d.Calib3d.estimateAffine2D(srcRef, dstRef);            configCmType = 11;        }        Log.i(TAG, "Transform matrix: " + outputMat.dump());        printMat("rgb2thm " + configCmType, outputMat);        return outputMat;    }    public static void printMat(String name, Mat mat) {        String outputString = "";        outputString += "\nprintMat() " + name + " " + mat.rows() + " x " + mat.cols();        for (int i = 0; i < mat.rows(); i++) {            outputString += "\n";            for (int j = 0; j < mat.cols(); j++) {                outputString += String.format("%.16f,", mat.get(i, j)[0]); // -->  "-23.1234567890123456"            }        }        outputString += "\n";        Log.i(TAG, "matrix: " + outputString);    }    public static Mat get2dAlignementMatrixs(int type, int distance) {        Mat outputMat = null;        boolean found = false;        if (type >= 5 && type <= 7) {            outputMat = new Mat(3, 3, CvType.CV_64F);            if (extrinsic2dAlignementMatrixs4p != null) {                for (int i = 0; i < extrinsic2dAlignementMatrixs4p.length; i++) {                    if (extrinsic2dAlignementMatrixs4p[i][2] == type) {                        if (distance >= HomographyHelper.extrinsic2dAlignementMatrixs4p[i][0] && distance <= HomographyHelper.extrinsic2dAlignementMatrixs4p[i][1]) {                            outputMat.put(0, 0, extrinsic2dAlignementMatrixs4p[i][5]);                            outputMat.put(0, 1, extrinsic2dAlignementMatrixs4p[i][6]);                            outputMat.put(0, 2, extrinsic2dAlignementMatrixs4p[i][7]);                            outputMat.put(1, 0, extrinsic2dAlignementMatrixs4p[i][8]);                            outputMat.put(1, 1, extrinsic2dAlignementMatrixs4p[i][9]);                            outputMat.put(1, 2, extrinsic2dAlignementMatrixs4p[i][10]);                            outputMat.put(2, 0, extrinsic2dAlignementMatrixs4p[i][11]);                            outputMat.put(2, 1, extrinsic2dAlignementMatrixs4p[i][12]);                            outputMat.put(2, 2, extrinsic2dAlignementMatrixs4p[i][13]);                            found = true;                        }                    }                }                //printMat("2dAlignementMatrix", outputMat);            }            if (!found) {                outputMat.put(0, 0, 1.0);                outputMat.put(1, 0, 1.0);                outputMat.put(2, 0, 1.0);                outputMat.put(0, 1, 1.0);                outputMat.put(1, 1, 1.0);                outputMat.put(2, 1, 1.0);                outputMat.put(0, 2, 1.0);                outputMat.put(1, 2, 1.0);                outputMat.put(2, 2, 1.0);            }        } else {            outputMat = new Mat(2, 3, CvType.CV_64F);            if (extrinsic2dAlignementMatrixs3p != null) {                Log.i(TAG, "extrinsic2dAlignementMatrixs3p, type : " + String.valueOf(type) + " distance : " + String.valueOf(distance));                for (int i = 0; i < extrinsic2dAlignementMatrixs3p.length; i++) {                    if (extrinsic2dAlignementMatrixs3p[i][2] == type) {                        if (distance >= HomographyHelper.extrinsic2dAlignementMatrixs3p[i][0] && distance <= HomographyHelper.extrinsic2dAlignementMatrixs3p[i][1]) {                            outputMat.put(0, 0, extrinsic2dAlignementMatrixs3p[i][5]);                            outputMat.put(0, 1, extrinsic2dAlignementMatrixs3p[i][6]);                            outputMat.put(0, 2, extrinsic2dAlignementMatrixs3p[i][7] * distance + extrinsic2dAlignementMatrixs3p[i][11]);                            outputMat.put(1, 0, extrinsic2dAlignementMatrixs3p[i][8]);                            outputMat.put(1, 1, extrinsic2dAlignementMatrixs3p[i][9]);                            outputMat.put(1, 2, extrinsic2dAlignementMatrixs3p[i][10] * distance + extrinsic2dAlignementMatrixs3p[i][12]);                            found = true;                        }                    }                }                //printMat("2dAlignementMatrix3p", outputMat);            }            if (!found) {                outputMat.put(0, 0, 1.0);                outputMat.put(1, 0, 1.0);                outputMat.put(2, 0, 1.0);                outputMat.put(0, 1, 1.0);                outputMat.put(1, 1, 1.0);                outputMat.put(2, 1, 1.0);            }        }        return outputMat;    }    public static org.opencv.core.Mat getAlignmedImg(String filePathName, org.opencv.core.Size targetSize, org.opencv.core.Mat transformMatrix, int type) {        Mat oriImage = null;        if (!AppResultReceiver.dataEncrypt)            oriImage = Imgcodecs.imread(filePathName);        else            oriImage = FileHelper.imreadSecret(filePathName);        return getAlignmedImg(oriImage, targetSize, transformMatrix, type);    }    public static org.opencv.core.Mat getAlignmedImg(Mat oriImage, org.opencv.core.Size targetSize, org.opencv.core.Mat transformMatrix, int type) {        Mat outputMat = new Mat(targetSize, CvType.CV_8UC3);        if (type >= 5 && type <= 7)            org.opencv.imgproc.Imgproc.warpPerspective(oriImage, outputMat, transformMatrix, targetSize);        else            org.opencv.imgproc.Imgproc.warpAffine(oriImage, outputMat, transformMatrix, targetSize);        return outputMat;    }    public static org.opencv.core.Mat getAlignmedImg32FC1(Mat oriImage, org.opencv.core.Size targetSize, org.opencv.core.Mat transformMatrix, int type) {        Mat outputMat = new Mat(targetSize, CvType.CV_32FC1);        if (type >= 5 && type <= 7)            org.opencv.imgproc.Imgproc.warpPerspective(oriImage, outputMat, transformMatrix, targetSize);        else            org.opencv.imgproc.Imgproc.warpAffine(oriImage, outputMat, transformMatrix, targetSize);        return outputMat;    }    public static org.opencv.core.Point3 rgb2sensingCoord(org.opencv.core.Point3 pt, org.opencv.core.Mat transformMatrix) {        org.opencv.core.Point3 outputValue = new org.opencv.core.Point3();        Mat dstPoint = new Mat();        Mat srcPoint = new Mat();        srcPoint.push_back(new MatOfPoint2f(new Point(pt.x, pt.y)));        org.opencv.core.Core.perspectiveTransform(srcPoint, dstPoint, transformMatrix);        outputValue.x = dstPoint.get(0, 0)[0];        outputValue.y = dstPoint.get(0, 0)[1];        return outputValue;    }    public static org.opencv.core.Point3 rgb2sensingCoordAffine(org.opencv.core.Point3 pt, org.opencv.core.Mat transformMatrix) {        org.opencv.core.Point3 outputValue = new org.opencv.core.Point3();        Mat dstPoint = new Mat();        Mat srcPoint = new Mat();        srcPoint.push_back(new MatOfPoint3f(new Point3(pt.x, pt.y, 1.0)));        org.opencv.core.Core.transform(srcPoint, dstPoint, transformMatrix);        outputValue.x = dstPoint.get(0, 0)[0];        outputValue.y = dstPoint.get(0, 0)[1];        return outputValue;    }    public static double getSensingValueWithRgbCoord(org.opencv.core.Point3 pt, org.opencv.core.Mat transformMatrix, Mat sensingImg) throws Exception {        double outputValue = 0.0;        org.opencv.core.Point3 newpt;        if (Model3DHelper.mMatrixWarpType == HomographyHelper.MATRIX_WARP_TYPE_4P_WARPPERSPECTIVE)            newpt = rgb2sensingCoord(pt, transformMatrix);        else            newpt = rgb2sensingCoordAffine(pt, transformMatrix);        Log.v(TAG,"x : "+newpt.x+", y : "+newpt.y );        outputValue = getSensingValue(newpt, sensingImg);        return outputValue;    }    public static double getSensingValue(org.opencv.core.Point3 pt, Mat sensingImg) throws Exception {        double outputValue = 0.0;        if ((pt.y >= 0 && pt.y < sensingImg.rows())                && (pt.x >= 0 && pt.x < sensingImg.cols())) {            outputValue = sensingImg.get((int) pt.y, (int) pt.x)[0];        } else            throw new Exception("error point x:" + pt.x + ", y:" + pt.y);        return outputValue;    }//    public static Mat getDisplayHomography(Context context) {////        MatOfPoint2f dstRef = new MatOfPoint2f();//        MatOfPoint2f srcRef = new MatOfPoint2f();////        BufferedReader br = null;//        String line = "";//        String cvsSplitBy = ",";//        int dataLineCount = 0;//        try {//            AssetManager assetManager = context.getAssets();//            InputStream inputStream = assetManager.open("homography_disp_" + Build.MODEL.replace(" ", "_") + ".csv");//            br = new BufferedReader(new InputStreamReader(inputStream));//            while ((line = br.readLine()) != null) {//                line = line.trim();//                if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {//                } else {//                    dataLineCount++;//                    String[] data = line.split(cvsSplitBy);//                    if (dataLineCount < 5)//                        srcRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[0]), Integer.valueOf(data[1]))));//                    else//                        dstRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[0]), Integer.valueOf(data[1]))));//                }//            }//        } catch (Exception ex) {//            ex.printStackTrace();//        } finally {//            if (br != null) {//                try {//                    br.close();//                } catch (Exception e) {//                    e.printStackTrace();//                }//            }//        }////        if (dataLineCount != 8) {//            srcRef.release();//            srcRef = new MatOfPoint2f();//            dstRef.release();//            dstRef = new MatOfPoint2f();//            srcRef.push_back(new MatOfPoint2f(new Point(83, 40)));//            srcRef.push_back(new MatOfPoint2f(new Point(571, 31)));//            srcRef.push_back(new MatOfPoint2f(new Point(575, 329)));//            srcRef.push_back(new MatOfPoint2f(new Point(79, 320)));//            dstRef.push_back(new MatOfPoint2f(new Point(2376, 520)));//            dstRef.push_back(new MatOfPoint2f(new Point(2424, 3584)));//            dstRef.push_back(new MatOfPoint2f(new Point(576, 3600)));//            dstRef.push_back(new MatOfPoint2f(new Point(624, 520)));//            dataLineCount = 8;//        }////        Mat OutputMat = new Mat();//        if (dataLineCount != 8)//            return null;//        else//            return org.opencv.calib3d.Calib3d.findHomography(srcRef, dstRef, org.opencv.calib3d.Calib3d.RANSAC, 10, OutputMat);//    }////    public static Mat getImageAlignmentHomography(Context context) {////        MatOfPoint2f dstRef = new MatOfPoint2f();//        MatOfPoint2f srcRef = new MatOfPoint2f();////        BufferedReader br = null;//        String line = "";//        String cvsSplitBy = ",";//        int dataLineCount = 0;////        File file = null;//        try {//            file = new File("file:///android_asset/mldata/homography_pic_" + Build.MODEL.replace(" ", "_") + ".csv");//            if (file.exists() && file.canRead()) {//                AssetManager assetManager = context.getAssets();//                InputStream inputStream = assetManager.open("mldata/homography_pic_" + Build.MODEL.replace(" ", "_") + ".csv");//                br = new BufferedReader(new InputStreamReader(inputStream));//                while ((line = br.readLine()) != null) {//                    line = line.trim();//                    if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {//                    } else {//                        dataLineCount++;//                        String[] data = line.split(cvsSplitBy);//                        if (dataLineCount < 5)//                            srcRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[0]), Integer.valueOf(data[1]))));//                        else//                            dstRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[0]), Integer.valueOf(data[1]))));//                    }//                }//            }//        } catch (Exception ex) {//            ex.printStackTrace();//        } finally {//            if (br != null) {//                try {//                    br.close();//                } catch (Exception e) {//                    e.printStackTrace();//                }//            }//        }////        if (dataLineCount != 8) {//            //ref from Mi 8T//            srcRef.release();//            srcRef = new MatOfPoint2f();//            dstRef.release();//            dstRef = new MatOfPoint2f();//            srcRef.push_back(new MatOfPoint2f(new Point(83, 40)));//            srcRef.push_back(new MatOfPoint2f(new Point(571, 31)));//            srcRef.push_back(new MatOfPoint2f(new Point(575, 329)));//            srcRef.push_back(new MatOfPoint2f(new Point(79, 320)));//            dstRef.push_back(new MatOfPoint2f(new Point(2376, 520)));//            dstRef.push_back(new MatOfPoint2f(new Point(2424, 3584)));//            dstRef.push_back(new MatOfPoint2f(new Point(576, 3600)));//            dstRef.push_back(new MatOfPoint2f(new Point(624, 520)));//            dataLineCount = 8;//        }////        Mat OutputMat = new Mat();//        if (dataLineCount != 8)//            return null;//        else//            return org.opencv.calib3d.Calib3d.findHomography(srcRef, dstRef, org.opencv.calib3d.Calib3d.RANSAC, 10, OutputMat);//    }////    public static Mat getAlignmentHomography(Context context) {////        MatOfPoint2f dstRef = new MatOfPoint2f();//        MatOfPoint2f srcRef = new MatOfPoint2f();////        BufferedReader br = null;//        String line = "";//        String cvsSplitBy = ",";//        int dataLineCount = 0;//        try {//            AssetManager assetManager = context.getAssets();//            InputStream inputStream = assetManager.open("homography_disp_" + Build.MODEL.replace(" ", "_") + ".csv");//            br = new BufferedReader(new InputStreamReader(inputStream));//            while ((line = br.readLine()) != null) {//                line = line.trim();//                if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {//                } else {//                    dataLineCount++;//                    String[] data = line.split(cvsSplitBy);//                    if (dataLineCount < 5)//                        srcRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[0]), Integer.valueOf(data[1]))));//                    else//                        dstRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[0]), Integer.valueOf(data[1]))));//                }//            }//        } catch (Exception ex) {//            ex.printStackTrace();//        } finally {//            if (br != null) {//                try {//                    br.close();//                } catch (Exception e) {//                    e.printStackTrace();//                }//            }//        }////        if (dataLineCount != 8) {//            srcRef.release();//            srcRef = new MatOfPoint2f();//            dstRef.release();//            dstRef = new MatOfPoint2f();//            srcRef.push_back(new MatOfPoint2f(new Point(83, 40)));//            srcRef.push_back(new MatOfPoint2f(new Point(571, 31)));//            srcRef.push_back(new MatOfPoint2f(new Point(575, 329)));//            srcRef.push_back(new MatOfPoint2f(new Point(79, 320)));//            dstRef.push_back(new MatOfPoint2f(new Point(2376, 520)));//            dstRef.push_back(new MatOfPoint2f(new Point(2424, 3584)));//            dstRef.push_back(new MatOfPoint2f(new Point(576, 3600)));//            dstRef.push_back(new MatOfPoint2f(new Point(624, 520)));//            dataLineCount = 8;//        }////        Mat OutputMat = new Mat();//        if (dataLineCount != 8)//            return null;//        else//            return org.opencv.calib3d.Calib3d.findHomography(srcRef, dstRef, org.opencv.calib3d.Calib3d.RANSAC, 10, OutputMat);//    }////    public static Mat getAlignedImage(Context context) {////        MatOfPoint2f dstRef = new MatOfPoint2f();//        MatOfPoint2f srcRef = new MatOfPoint2f();////        BufferedReader br = null;//        String line = "";//        String cvsSplitBy = ",";//        int dataLineCount = 0;//        try {//            AssetManager assetManager = context.getAssets();//            InputStream inputStream = assetManager.open("homography_disp_" + Build.MODEL.replace(" ", "_") + ".csv");//            br = new BufferedReader(new InputStreamReader(inputStream));//            while ((line = br.readLine()) != null) {//                line = line.trim();//                if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {//                } else {//                    dataLineCount++;//                    String[] data = line.split(cvsSplitBy);//                    if (dataLineCount < 5)//                        srcRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[0]), Integer.valueOf(data[1]))));//                    else//                        dstRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[0]), Integer.valueOf(data[1]))));//                }//            }//        } catch (Exception ex) {//            ex.printStackTrace();//        } finally {//            if (br != null) {//                try {//                    br.close();//                } catch (Exception e) {//                    e.printStackTrace();//                }//            }//        }////        if (dataLineCount != 8) {//            srcRef.release();//            srcRef = new MatOfPoint2f();//            dstRef.release();//            dstRef = new MatOfPoint2f();//            srcRef.push_back(new MatOfPoint2f(new Point(83, 40)));//            srcRef.push_back(new MatOfPoint2f(new Point(571, 31)));//            srcRef.push_back(new MatOfPoint2f(new Point(575, 329)));//            srcRef.push_back(new MatOfPoint2f(new Point(79, 320)));//            dstRef.push_back(new MatOfPoint2f(new Point(2376, 520)));//            dstRef.push_back(new MatOfPoint2f(new Point(2424, 3584)));//            dstRef.push_back(new MatOfPoint2f(new Point(576, 3600)));//            dstRef.push_back(new MatOfPoint2f(new Point(624, 520)));//            dataLineCount = 8;//        }////        Mat OutputMat = new Mat();//        if (dataLineCount != 8)//            return null;//        else//            return org.opencv.calib3d.Calib3d.findHomography(srcRef, dstRef, org.opencv.calib3d.Calib3d.RANSAC, 10, OutputMat);//    }////    public static double getAlignedImageXY(Context context, int x, int y) {////        MatOfPoint2f dstRef = new MatOfPoint2f();//        MatOfPoint2f srcRef = new MatOfPoint2f();////        BufferedReader br = null;//        String line = "";//        String cvsSplitBy = ",";//        int dataLineCount = 0;//        try {//            AssetManager assetManager = context.getAssets();//            InputStream inputStream = assetManager.open("homography_disp_" + Build.MODEL.replace(" ", "_") + ".csv");//            br = new BufferedReader(new InputStreamReader(inputStream));//            while ((line = br.readLine()) != null) {//                line = line.trim();//                if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {//                } else {//                    dataLineCount++;//                    String[] data = line.split(cvsSplitBy);//                    if (dataLineCount < 5)//                        srcRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[0]), Integer.valueOf(data[1]))));//                    else//                        dstRef.push_back(new MatOfPoint2f(new Point(Integer.valueOf(data[0]), Integer.valueOf(data[1]))));//                }//            }//        } catch (Exception ex) {//            ex.printStackTrace();//        } finally {//            if (br != null) {//                try {//                    br.close();//                } catch (Exception e) {//                    e.printStackTrace();//                }//            }//        }////        if (dataLineCount != 8) {//            srcRef.release();//            srcRef = new MatOfPoint2f();//            dstRef.release();//            dstRef = new MatOfPoint2f();//            srcRef.push_back(new MatOfPoint2f(new Point(83, 40)));//            srcRef.push_back(new MatOfPoint2f(new Point(571, 31)));//            srcRef.push_back(new MatOfPoint2f(new Point(575, 329)));//            srcRef.push_back(new MatOfPoint2f(new Point(79, 320)));//            dstRef.push_back(new MatOfPoint2f(new Point(2376, 520)));//            dstRef.push_back(new MatOfPoint2f(new Point(2424, 3584)));//            dstRef.push_back(new MatOfPoint2f(new Point(576, 3600)));//            dstRef.push_back(new MatOfPoint2f(new Point(624, 520)));//            dataLineCount = 8;//        }////        Mat OutputMat = new Mat();//        if (dataLineCount != 8)//            return 0.0;//        else//            return 1.0;//    }}