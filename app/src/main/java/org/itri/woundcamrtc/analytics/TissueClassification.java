package org.itri.woundcamrtc.analytics;import android.content.Context;import android.content.SharedPreferences;import android.content.res.AssetFileDescriptor;import android.content.res.AssetManager;import android.graphics.Color;import android.os.Environment;import android.preference.PreferenceManager;import android.util.Log;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.math.BigDecimal;import java.util.ArrayList;import java.util.Date;import java.util.List;import org.itri.woundcamrtc.AppResultReceiver;import org.itri.woundcamrtc.helper.FileHelper;import org.opencv.core.CvType;import org.opencv.core.Mat;import org.opencv.core.Scalar;import org.opencv.core.TermCriteria;import org.opencv.imgcodecs.Imgcodecs;import org.opencv.imgproc.Imgproc;import org.opencv.ml.ANN_MLP;import org.opencv.ml.Boost;import org.opencv.ml.DTrees;import org.opencv.ml.KNearest;import org.opencv.ml.LogisticRegression;import org.opencv.ml.Ml;import org.opencv.ml.NormalBayesClassifier;import org.opencv.ml.RTrees;import org.opencv.ml.SVM;import org.opencv.ml.SVMSGD;import org.opencv.ml.StatModel;import org.opencv.ml.TrainData;import static android.support.constraint.Constraints.TAG;public class TissueClassification {    //public static String modelFileName = "wound_training_4class_201812";    public static String modelFileName = "wound_training_4class_202001a";    public static boolean validationPrintOut = false;    private static ArrayList<List<String>> TissueAnalysisResult = new ArrayList<List<String>>();    public static ArrayList<List<String>> getTissueAnalysisResult() {        return TissueAnalysisResult;    }    public static DTrees dtreesClassier = null;    public static SVM svmClassier = null;    public static RTrees rtreesClassier = null;    public static KNearest knearestClassier = null;    public static boolean checkDTreesInstance() {        if (dtreesClassier == null)            return false;        else            return true;    }    public static boolean checkSVMInstance() {        if (svmClassier == null)            return false;        else            return true;    }    public static boolean checkRTreesInstance() {        if (rtreesClassier == null)            return false;        else            return true;    }    public static boolean checkKNearestInstance() {        if (knearestClassier == null)            return false;        else            return true;    }    public static float[] rgb2hsv(int r, int g, int b) {        float[] hsv = new float[3];        Color.RGBToHSV(r, g, b, hsv);        return hsv;    }    public static int[] rgb2ycbcr(int R, int G, int B) {        int Y = (int) Math.round((0.299 * R + 0.587 * G + 0.114 * B));        int Cb = (int) Math.round((-0.1687 * R - 0.3313 * G + 0.5 * B + 128));        int Cr = (int) Math.round((0.5 * R - 0.4187 * G - 0.0813 * B + 128));        return new int[]{Y, Cb, Cr};    }    public static int[] rgb2lab(int R, int G, int B) {        //http://www.brucelindbloom.com        float r, g, b, X, Y, Z, fx, fy, fz, xr, yr, zr;        float Ls, as, bs;        float eps = 216.f / 24389.f;        float k = 24389.f / 27.f;        float Xr = 0.964221f;  // reference white D50        float Yr = 1.0f;        float Zr = 0.825211f;        // RGB to XYZ        r = R / 255.f; //R 0..1        g = G / 255.f; //G 0..1        b = B / 255.f; //B 0..1        // assuming sRGB (D65)        if (r <= 0.04045)            r = r / 12;        else            r = (float) Math.pow((r + 0.055) / 1.055, 2.4);        if (g <= 0.04045)            g = g / 12;        else            g = (float) Math.pow((g + 0.055) / 1.055, 2.4);        if (b <= 0.04045)            b = b / 12;        else            b = (float) Math.pow((b + 0.055) / 1.055, 2.4);        X = 0.436052025f * r + 0.385081593f * g + 0.143087414f * b;        Y = 0.222491598f * r + 0.71688606f * g + 0.060621486f * b;        Z = 0.013929122f * r + 0.097097002f * g + 0.71418547f * b;        // XYZ to Lab        xr = X / Xr;        yr = Y / Yr;        zr = Z / Zr;        if (xr > eps)            fx = (float) Math.pow(xr, 1 / 3.);        else            fx = (float) ((k * xr + 16.) / 116.);        if (yr > eps)            fy = (float) Math.pow(yr, 1 / 3.);        else            fy = (float) ((k * yr + 16.) / 116.);        if (zr > eps)            fz = (float) Math.pow(zr, 1 / 3.);        else            fz = (float) ((k * zr + 16.) / 116);        Ls = (116 * fy) - 16;        as = 500 * (fx - fy);        bs = 200 * (fy - fz);        return new int[]{(int) (2.55 * Ls + .5), (int) (as + .5), (int) (bs + .5)};//        lab[0] = (int) (2.55*Ls + .5);//        lab[1] = (int) (as + .5);//        lab[2] = (int) (bs + .5);    }    public static boolean classifier_DTrees_4class_build(final Context context) {        int build = 201812;        int kClass = 4;        int features = 5;        int maxN = 277849;        switch (build) {            case 201812:                features = 5;            default:                break;        }        //prepare trainData and trainLabel        Mat trainingData = new Mat(maxN, features, CvType.CV_32FC1, new Scalar(0));        Mat trainingLabel = new Mat(maxN, 1, CvType.CV_32SC1, new Scalar(0));        BufferedReader br = null;        String line = "";        String cvsSplitBy = ",";        int samplingN = -1;        try {            AssetManager assetManager = context.getAssets();            InputStream inputStream = assetManager.open("mldata/" + modelFileName + ".csv");            br = new BufferedReader(new InputStreamReader(inputStream));            while ((line = br.readLine()) != null) {                line = line.trim();                if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {                } else {                    // use comma as separator                    String[] data = line.split(cvsSplitBy);                    samplingN++;                    float[] hsv = rgb2hsv(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                    //int[] ycbcr = rgb2ycbcr(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                    //int[] lab = rgb2lab(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                    switch (build) {                        case 201812:                            // R/G, G/B, R/B                            double RdivG = (double) (Double.parseDouble(data[1] + 1) / (double) Double.parseDouble(data[2] + 1));                            double GdivB = (double) (Double.parseDouble(data[2] + 1) / (double) Double.parseDouble(data[3] + 1));                            //double BdivG = (double) (Double.parseDouble(data[3] + 1) / (double) Double.parseDouble(data[2] + 1));                            trainingData.put(samplingN, 0, RdivG);                            trainingData.put(samplingN, 1, RdivG - GdivB);                            trainingData.put(samplingN, 2, hsv[0]);                            trainingData.put(samplingN, 3, hsv[1]);                            trainingData.put(samplingN, 4, hsv[2]);                        default:                            break;                    }                    trainingLabel.put(samplingN, 0, Integer.parseInt(data[0]));                }                if (samplingN >= maxN)                    break;            }        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (Exception e) {            e.printStackTrace();        } finally {            if (br != null) {                try {                    br.close();                } catch (Exception e) {                    e.printStackTrace();                }            }        }        trainingData = trainingData.submat(0, samplingN, 0, features);        trainingLabel = trainingLabel.submat(0, samplingN, 0, 1);        DTrees classier = DTrees.create();        classier.setMaxDepth(8); //設定最大深度        classier.setMinSampleCount(2);        classier.setUseSurrogates(false);        classier.setCVFolds(0); //交叉驗證,//set 10,it will get Exception in thread "main" java.lang.Exception: unknown exception        classier.setUse1SERule(false);        classier.setTruncatePrunedTree(false);        boolean success = classier.train(trainingData, Ml.ROW_SAMPLE, trainingLabel);        if (success) {            try {                classier.save(AppResultReceiver.ROOT_FOLDER_PATH + "/" + modelFileName + "_dtrees.xml");            } catch (Exception e) {                e.printStackTrace();                success = false;            }        }        if (validationPrintOut) {            try {                Mat responseMat = new Mat();                float response = classier.predict(trainingData, responseMat, 0);                //System.out.println("Dtrees responseMat:\n" + responseMat.dump());                int error = 0;                int correct = 0;                for (int i = 0; i < responseMat.height(); i++) {                    if (responseMat.get(i, 0)[0] == trainingLabel.get(i, 0)[0]) {                        correct++;                        //Log.d("TissueClassification", "predict: " + trainingLabel.get(i,0)[0] + " to " + responseMat.get(i, 0)[0] + " from " + trainingData.get(i, 0)[0] + "," + trainingData.get(i, 1)[0] + "," + trainingData.get(i, 2)[0]);                    } else {                        error++;                        Log.d("TissueClassification", "predict: (" + i + ")" + trainingLabel.get(i, 0)[0] + " to " + responseMat.get(i, 0)[0] + " from " + trainingData.get(i, 0)[0] + "," + trainingData.get(i, 1)[0] + "," + trainingData.get(i, 2)[0]);                    }                }                Log.d("TissueClassification", "accuracy: " + (double) correct / (double) (correct + error));            } catch (Exception e) {                e.printStackTrace();            } finally {            }        }        return success;    }    public static void classifier_DTrees_4class_fromxml(final Mat frame, final Mat saving_mask, final Context context) {        //Imgcodecs.imwrite(AppResultReceiver.ROOT_FOLDER_PATH + "/classified_mask.png", saving_mask);        //Imgcodecs.imwrite(AppResultReceiver.ROOT_FOLDER_PATH + "/classified_image.png", frame);        int build = 201812;        int kClass = 4;        int features = 5;        switch (build) {            case 201812:                features = 5;            default:                break;        }        DTrees classier = null;        if (dtreesClassier == null)            dtreesClassier = DTrees.load(AppResultReceiver.ROOT_FOLDER_PATH + "/" + modelFileName + "_dtrees.xml");        classier = dtreesClassier;        if (classier != null && saving_mask != null && saving_mask.width() > 0) {            //find the nearest neighbours of test data            Mat results = new Mat();            Mat neighborResponses = new Mat();            Mat dists = new Mat();            int[] predictedLabel = new int[kClass];            for (int i = 0; i < kClass; i++) predictedLabel[i] = 0;            int pixel_count = 0;            int i, j;            for (i = 0; i < frame.rows(); i++) {                for (j = 0; j < frame.cols(); j++) {                    if (saving_mask.get(i, j)[0] == 0)                        continue;//                double dataHSV[] = frame.get(i, j);                    double dataBGR[] = frame.get(i, j);//prepare test data                    Mat testData = new Mat(1, features, CvType.CV_32FC1, new Scalar(1));                    float[] hsv = rgb2hsv((int) dataBGR[2], (int) dataBGR[1], (int) dataBGR[0]);                    //int[] ycbcr = rgb2ycbcr((int) dataBGR[2], (int) dataBGR[1], (int) dataBGR[0]);                    //int[] lab = rgb2lab((int) dataBGR[2], (int) dataBGR[1], (int) dataBGR[0]);                    switch (build) {                        case 201812:                            // R/G, G/B, R/B                            double RdivG = (double) (dataBGR[2] + 1) / (double) (dataBGR[1] + 1);                            double GdivB = (double) (dataBGR[1] + 1) / (double) (dataBGR[0] + 1);                            //double BdivG = (double) (dataBGR[0] + 1) / (double) (dataBGR[1] + 1);                            testData.put(0, 0, RdivG);                            testData.put(0, 1, RdivG - GdivB);                            testData.put(0, 2, (double) hsv[0]);                            testData.put(0, 3, (double) hsv[1]);                            testData.put(0, 4, (double) hsv[2]);                        default:                            break;                    }                    float p = classier.predict(testData, results, 0);                    testData.release();                    int result = Integer.valueOf(results.dump().replace("[", "").replace("]", ""));                    pixel_count++;                    switch (result) {                        case 0:                            predictedLabel[0]++;                            break;                        case 1:                            predictedLabel[1]++;                            break;                        case 2:                            predictedLabel[2]++;                            break;                        case 3:                            predictedLabel[3]++;                            break;                        case 4:                            predictedLabel[4]++;                            break;                        case 5:                            predictedLabel[5]++;                            break;                        case 6:                            predictedLabel[6]++;                            break;                        case 7:                            predictedLabel[7]++;                            break;                        default:                            break;                    }                }            }            List<String> title = new ArrayList<String>();            title.add("上:");            title.add("芽:");            title.add("腐:");            title.add("焦:");//        Epithelial 嫩皮//        Granulation 芽//        Sloughy 腐//        Necrosis 焦//        Exudate 滲//        Maceration 浸//        Swelling 腫            TissueAnalysisResult.clear();            List<String> result1 = new ArrayList<String>();            int value1 = Math.round(100 * (float) predictedLabel[0] / pixel_count);            result1.add(title.get(0));            result1.add(Integer.toString(value1) + "%");            TissueAnalysisResult.add(result1);            List<String> result2 = new ArrayList<String>();            int value2 = Math.round(100 * (float) (predictedLabel[1]) / pixel_count);            result2.add(title.get(1));            result2.add(Integer.toString(value2) + "%");            TissueAnalysisResult.add(result2);            List<String> result3 = new ArrayList<String>();            int value3 = Math.round(100 * (float) (predictedLabel[2]) / pixel_count);            result3.add(title.get(2));            result3.add(Integer.toString(value3) + "%");            TissueAnalysisResult.add(result3);            List<String> result4 = new ArrayList<String>();            int value4 = Math.round(100 * (float) (predictedLabel[3]) / pixel_count);            if ((value1 + value2 + value3 + value4) > 100 || (value1 + value2 + value3 + value4) < 100)                value4 = 100 - value1 - value2 - value3;            result4.add(title.get(3));            result4.add(Integer.toString(value4) + "%");            TissueAnalysisResult.add(result4);        }    }    public static boolean classifier_svm_4class_build(final Context context) {        int build = 201812;        int kClass = 4;        int features = 6;        int maxN = 277849;        switch (build) {            case 201812:                features = 6;            default:                break;        }        //prepare trainData and trainLabel        Mat trainingData = new Mat(maxN, features, CvType.CV_32FC1, new Scalar(0));        Mat trainingLabel = new Mat(maxN, 1, CvType.CV_32SC1, new Scalar(0));        BufferedReader br = null;        String line = "";        String cvsSplitBy = ",";        int samplingN = -1;        try {            AssetManager assetManager = context.getAssets();            InputStream inputStream = assetManager.open("mldata/" + modelFileName + ".csv");            br = new BufferedReader(new InputStreamReader(inputStream));            while ((line = br.readLine()) != null) {                line = line.trim();                if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {                } else {                    // use comma as separator                    String[] data = line.split(cvsSplitBy);                    samplingN++;                    float[] hsv = rgb2hsv(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                    //int[] ycbcr = rgb2ycbcr(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                    int[] lab = rgb2lab(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                    switch (build) {                        case 201812:                            // R/G, G/B, R/B                            //double RdivG = (double) (Double.parseDouble(data[1] + 1) / (double) Double.parseDouble(data[2] + 1));                            //double GdivB = (double) (Double.parseDouble(data[2] + 1) / (double) Double.parseDouble(data[3] + 1));                            //double BdivG = (double) (Double.parseDouble(data[3] + 1) / (double) Double.parseDouble(data[2] + 1));                            trainingData.put(samplingN, 0, hsv[0]);                            trainingData.put(samplingN, 1, hsv[1]);                            trainingData.put(samplingN, 2, hsv[2]);                            trainingData.put(samplingN, 3, lab[0]);                            trainingData.put(samplingN, 4, lab[1]);                            trainingData.put(samplingN, 5, lab[2]);                        default:                            break;                    }                    trainingLabel.put(samplingN, 0, Integer.parseInt(data[0]));                }                if (samplingN >= maxN)                    break;            }        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (Exception e) {            e.printStackTrace();        } finally {            if (br != null) {                try {                    br.close();                } catch (Exception e) {                    e.printStackTrace();                }            }        }        trainingData = trainingData.submat(0, samplingN, 0, features);        trainingLabel = trainingLabel.submat(0, samplingN, 0, 1);        SVM classier = SVM.create();        classier.setKernel(SVM.RBF);        classier.setType(SVM.C_SVC);        //TermCriteria criteria = new TermCriteria(TermCriteria.EPS + TermCriteria.MAX_ITER, 1000, 1e-6);        //classier.setTermCriteria(criteria);        //classier.setGamma(0.0001);        //classier.setNu(0.5);        //classier.setC(100);        //boolean success = classier.trainAuto(td.getSamples(), Ml.ROW_SAMPLE, td.getResponses());        //boolean success = classier.train(trainingData, Ml.ROW_SAMPLE, trainingLabel);        boolean success = classier.trainAuto(trainingData, Ml.ROW_SAMPLE, trainingLabel);        if (success) {            try {                classier.save(AppResultReceiver.ROOT_FOLDER_PATH + "/" + modelFileName + "_svm.xml");            } catch (Exception e) {                e.printStackTrace();                success = false;            }        }        if (validationPrintOut) {            try {                Mat responseMat = new Mat();                float response = classier.predict(trainingData, responseMat, 0);                //System.out.println("SVM responseMat:\n" + responseMat.dump());                int error = 0;                int correct = 0;                for (int i = 0; i < responseMat.height(); i++) {                    if (responseMat.get(i, 0)[0] == trainingLabel.get(i, 0)[0]) {                        correct++;                        //Log.d("TissueClassification", "predict: " + trainingLabel.get(i,0)[0] + " to " + responseMat.get(i, 0)[0] + " from " + trainingData.get(i, 0)[0] + "," + trainingData.get(i, 1)[0] + "," + trainingData.get(i, 2)[0]);                    } else {                        error++;                        Log.d("TissueClassification", "predict: (" + i + ")" + trainingLabel.get(i, 0)[0] + " to " + responseMat.get(i, 0)[0] + " from " + trainingData.get(i, 0)[0] + "," + trainingData.get(i, 1)[0] + "," + trainingData.get(i, 2)[0]);                    }                }                Log.d("TissueClassification", "accuracy: " + (double) correct / (double) (correct + error));            } catch (Exception e) {                e.printStackTrace();            } finally {            }        }        return success;    }    public static void classifier_svm_4class_fromxml(final Mat frame, final Mat saving_mask, final Context context) {//Imgcodecs.imwrite(AppResultReceiver.ROOT_FOLDER_PATH + "/classified_mask.png", saving_mask);        //Imgcodecs.imwrite(AppResultReceiver.ROOT_FOLDER_PATH + "/classified_image.png", frame);        int build = 201812;        int kClass = 4;        int features = 6;        switch (build) {            case 201812:                features = 6;            default:                break;        }        SVM classier = null;        if (svmClassier == null)            svmClassier = SVM.load(AppResultReceiver.ROOT_FOLDER_PATH + "/" + modelFileName + "_svm.xml");        classier = svmClassier;        if (classier != null && saving_mask != null && saving_mask.width() > 0) {            //find the nearest neighbours of test data            Mat results = new Mat();            Mat neighborResponses = new Mat();            Mat dists = new Mat();            int[] predictedLabel = new int[kClass];            for (int i = 0; i < kClass; i++) predictedLabel[i] = 0;            int pixel_count = 0;            int i, j;            for (i = 0; i < frame.rows(); i++) {                for (j = 0; j < frame.cols(); j++) {                    if (saving_mask.get(i, j)[0] == 0)                        continue;//                double dataHSV[] = frame.get(i, j);                    double dataBGR[] = frame.get(i, j);//prepare test data                    Mat testData = new Mat(1, features, CvType.CV_32FC1, new Scalar(1));                    float[] hsv = rgb2hsv((int) dataBGR[2], (int) dataBGR[1], (int) dataBGR[0]);                    //int[] ycbcr = rgb2ycbcr((int) dataBGR[2], (int) dataBGR[1], (int) dataBGR[0]);                    int[] lab = rgb2lab((int) dataBGR[2], (int) dataBGR[1], (int) dataBGR[0]);                    switch (build) {                        case 201812:                            // R/G, G/B, R/B                            //double RdivG = (double) (dataBGR[2] + 1) / (double) (dataBGR[1] + 1);                            //double GdivB = (double) (dataBGR[1] + 1) / (double) (dataBGR[0] + 1);                            //double BdivG = (double) (dataBGR[0] + 1) / (double) (dataBGR[1] + 1);                            testData.put(0, 0, (double) hsv[0]);                            testData.put(0, 1, (double) hsv[1]);                            testData.put(0, 2, (double) hsv[2]);                            testData.put(0, 3, (double) lab[0]);                            testData.put(0, 4, (double) lab[1]);                            testData.put(0, 5, (double) lab[2]);                        default:                            break;                    }                    float p = classier.predict(testData, results, 0);                    testData.release();                    int result = Integer.valueOf(results.dump().replace("[", "").replace("]", ""));                    pixel_count++;                    switch (result) {                        case 0:                            predictedLabel[0]++;                            break;                        case 1:                            predictedLabel[1]++;                            break;                        case 2:                            predictedLabel[2]++;                            break;                        case 3:                            predictedLabel[3]++;                            break;                        case 4:                            predictedLabel[4]++;                            break;                        case 5:                            predictedLabel[5]++;                            break;                        case 6:                            predictedLabel[6]++;                            break;                        case 7:                            predictedLabel[7]++;                            break;                        default:                            break;                    }                }            }            List<String> title = new ArrayList<String>();            title.add("上:");            title.add("芽:");            title.add("腐:");            title.add("焦:");//        Epithelial 嫩皮//        Granulation 芽//        Sloughy 腐//        Necrosis 焦//        Exudate 滲//        Maceration 浸//        Swelling 腫            TissueAnalysisResult.clear();            List<String> result1 = new ArrayList<String>();            int value1 = Math.round(100 * (float) predictedLabel[0] / pixel_count);            result1.add(title.get(0));            result1.add(Integer.toString(value1) + "%");            TissueAnalysisResult.add(result1);            List<String> result2 = new ArrayList<String>();            int value2 = Math.round(100 * (float) (predictedLabel[1]) / pixel_count);            result2.add(title.get(1));            result2.add(Integer.toString(value2) + "%");            TissueAnalysisResult.add(result2);            List<String> result3 = new ArrayList<String>();            int value3 = Math.round(100 * (float) (predictedLabel[2]) / pixel_count);            result3.add(title.get(2));            result3.add(Integer.toString(value3) + "%");            TissueAnalysisResult.add(result3);            List<String> result4 = new ArrayList<String>();            int value4 = Math.round(100 * (float) (predictedLabel[3]) / pixel_count);            if ((value1 + value2 + value3 + value4) > 100 || (value1 + value2 + value3 + value4) < 100)                value4 = 100 - value1 - value2 - value3;            result4.add(title.get(3));            result4.add(Integer.toString(value4) + "%");            TissueAnalysisResult.add(result4);        }////////        Imgcodecs.imwrite(AppResultReceiver.ROOT_FOLDER_PATH + "/grabcut_mask.png", saving_mask);////        int kClass = 4;//        int features = 3;//        SVM classier = SVM.load(AppResultReceiver.ROOT_FOLDER_PATH + "/" + modelFileName + "_svm.xml");////        if (classier != null && saving_mask != null && saving_mask.width() > 0) {//            //find the nearest neighbours of test data//            Mat results = new Mat();//            Mat neighborResponses = new Mat();//            Mat dists = new Mat();////            int[] predictedLabel = new int[kClass];//            for (int i = 0; i < kClass; i++) predictedLabel[i] = 0;////            int pixel_count = 0;//            int i, j;//            for (i = 0; i < frame.rows(); i++) {//                for (j = 0; j < frame.cols(); j++) {////                    if (saving_mask.get(i, j)[0] == 0)//                        continue;//////                double dataHSV[] = frame.get(i, j);//                    double dataBGR[] = frame.get(i, j);////prepare test data//                    Mat testData = new Mat(1, features, CvType.CV_32FC1, new Scalar(1));//////                    //float[] hsv = rgb2hsv((int) dataBGR[2], (int) dataBGR[1], (int) dataBGR[0]);//                    //int[] ycbcr = rgb2ycbcr((int) dataBGR[2], (int) dataBGR[1], (int) dataBGR[0]);//                    int[] lab = rgb2lab((int) dataBGR[2], (int) dataBGR[1], (int) dataBGR[0]);//                    ;////                    // R/G, G/B, R/B//                    double RdivG = (double) ((double) dataBGR[1] + 1.0 / ((double) dataBGR[2] + 1.0));//                    double GdivB = (double) ((double) dataBGR[2] + 1.0 / ((double) dataBGR[3] + 1.0));////                    testData.put(0, 0, RdivG);//                    testData.put(0, 1, RdivG - GdivB);//                    testData.put(0, 2, (double) lab[0]);//                    testData.put(0, 3, (double) lab[1]);//                    testData.put(0, 4, (double) lab[2]);//////                    float p = classier.predict(testData, results, StatModel.RAW_OUTPUT);//                    testData.release();////                    int result = Integer.valueOf(results.dump().replace("[", "").replace("]", ""));////                    pixel_count++;//                    switch (result) {//                        case 0://                            predictedLabel[0]++;//                            break;//                        case 1://                            predictedLabel[1]++;//                            break;//                        case 2://                            predictedLabel[2]++;//                            break;//                        case 3://                            predictedLabel[3]++;//                            break;//                        case 4://                            predictedLabel[4]++;//                            break;//                        case 5://                            predictedLabel[5]++;//                            break;//                        case 6://                            predictedLabel[6]++;//                            break;//                        case 7://                            predictedLabel[7]++;//                            break;//                        default://                            break;//                    }//                }//            }////            List<String> title = new ArrayList<String>();//            title.add("上:");//            title.add("芽:");//            title.add("腐:");//            title.add("焦:");//////        Epithelial 嫩皮////        Sloughy 腐////        Exudate 滲////        Granulation 芽////        Necrosis 焦////        Maceration 浸////        Swelling 腫//            TissueAnalysisResult.clear();////            List<String> result1 = new ArrayList<String>();//            int value1 = Math.round(100 * (float) predictedLabel[0] / pixel_count);//            result1.add(title.get(0));//            result1.add(Integer.toString(value1) + "%");//            TissueAnalysisResult.add(result1);////            List<String> result2 = new ArrayList<String>();//            int value2 = Math.round(100 * (float) (predictedLabel[1]) / pixel_count);//            result2.add(title.get(1));//            result2.add(Integer.toString(value2) + "%");//            TissueAnalysisResult.add(result2);////            List<String> result3 = new ArrayList<String>();//            int value3 = Math.round(100 * (float) (predictedLabel[2]) / pixel_count);//            result3.add(title.get(2));//            result3.add(Integer.toString(value3) + "%");//            TissueAnalysisResult.add(result3);////            List<String> result4 = new ArrayList<String>();//            int value4 = Math.round(100 * (float) (predictedLabel[3]) / pixel_count);//            result4.add(title.get(3));//            result4.add(Integer.toString(value4) + "%");//            TissueAnalysisResult.add(result4);//        }    }    public static boolean classifier_RTrees_4class_build(final Context context) {        int build = 201812;        int kClass = 4;        int features = 5;        int maxN = 277849;        switch (build) {            case 201812:                features = 5;            default:                break;        }        //prepare trainData and trainLabel        Mat trainingData = new Mat(maxN, features, CvType.CV_32FC1, new Scalar(1));        Mat trainingLabel = new Mat(maxN, 1, CvType.CV_32SC1, new Scalar(1));        BufferedReader br = null;        String line = "";        String cvsSplitBy = ",";        int samplingN = -1;        try {            AssetManager assetManager = context.getAssets();            InputStream inputStream = assetManager.open("mldata/" + modelFileName + ".csv");            br = new BufferedReader(new InputStreamReader(inputStream));            while ((line = br.readLine()) != null) {                line = line.trim();                if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {                } else {                    // use comma as separator                    String[] data = line.split(cvsSplitBy);                    samplingN++;                    float[] hsv = rgb2hsv(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                    int[] ycbcr = rgb2ycbcr(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                    int[] lab = rgb2lab(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                    switch (build) {                        case 201812:                            // R/G, G/B, R/B                            trainingData.put(samplingN, 0, (double) (Double.parseDouble(data[1] + 1) / (double) Double.parseDouble(data[2] + 1)));                            trainingData.put(samplingN, 1, (double) (Double.parseDouble(data[2] + 1) / (double) Double.parseDouble(data[3] + 1)));                            trainingData.put(samplingN, 2, (double) (Double.parseDouble(data[1] + 1) / (double) Double.parseDouble(data[3] + 1)));                            trainingData.put(samplingN, 3, (double) hsv[0]);                            trainingData.put(samplingN, 4, (double) ycbcr[0]);                        default:                            break;                    }                    trainingLabel.put(samplingN, 0, Double.parseDouble(data[0]));                }                if (samplingN >= maxN)                    break;            }        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (Exception e) {            e.printStackTrace();        } finally {            if (br != null) {                try {                    br.close();                } catch (Exception e) {                    e.printStackTrace();                }            }        }        trainingData = trainingData.submat(0, samplingN, 0, features);        trainingLabel = trainingLabel.submat(0, samplingN, 0, 1);        TrainData td = TrainData.create(trainingData, Ml.ROW_SAMPLE, trainingLabel);        //train data        RTrees classier = RTrees.create();        classier.setMaxDepth(100);        classier.setMinSampleCount(2);        classier.setRegressionAccuracy(0.001f);        classier.setUseSurrogates(false);        classier.setMaxCategories(4);        classier.setPriors(new Mat());        classier.setCalculateVarImportance(false);        classier.setActiveVarCount(5);        classier.setTermCriteria(new TermCriteria(TermCriteria.MAX_ITER, 1000, 0));        boolean success = classier.train(td.getSamples(), Ml.ROW_SAMPLE, td.getResponses());        if (success) {            try {                classier.save(AppResultReceiver.ROOT_FOLDER_PATH + "/" + modelFileName + "_rtrees.xml");                Mat var_importance = classier.getVarImportance();                if (!var_importance.empty()) {                    Log.d("TissueClassification", "var importance:");                    for (int i = 0; i < var_importance.total(); i++)                        Log.d("TissueClassification", i + " " + (double) var_importance.get(i, 0)[0]);                }            } catch (Exception e) {                e.printStackTrace();                success = false;            }        }        boolean printout = true;        if (printout) {            try {                AssetManager assetManager = context.getAssets();                InputStream inputStream = assetManager.open(modelFileName + ".csv");                br = new BufferedReader(new InputStreamReader(inputStream));                while ((line = br.readLine()) != null) {                    line = line.trim();                    if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {                    } else {                        // use comma as separator                        String[] data = line.split(cvsSplitBy);                        Mat testData = new Mat(1, features, CvType.CV_32FC1, new Scalar(1));                        float[] hsv = rgb2hsv(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                        int[] ycbcr = rgb2ycbcr(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                        int[] lab = rgb2lab(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                        switch (build) {                            case 201812:                                // R/G, G/B, R/B                                testData.put(0, 0, (double) (Double.parseDouble(data[1] + 1) / (double) Double.parseDouble(data[2] + 1)));                                testData.put(0, 1, (double) (Double.parseDouble(data[2] + 1) / (double) Double.parseDouble(data[3] + 1)));                                testData.put(0, 2, (double) (Double.parseDouble(data[1] + 1) / (double) Double.parseDouble(data[3] + 1)));                                testData.put(0, 3, (double) hsv[0]);                                testData.put(0, 4, (double) ycbcr[0]);                            default:                                break;                        }                        Mat results = new Mat();                        float p = classier.predict(testData, results, StatModel.RAW_OUTPUT);                        testData.release();                        int result = Integer.valueOf(results.dump().replace("[", "").replace("]", ""));                        //if (result != Integer.valueOf(data[0])) {                        Log.d("TissueClassification", "prd error: " + data[0] + " to " + result + " from " + data[1] + "," + data[2] + "," + data[3] + "," + hsv[0] + "," + ycbcr[0]);                        //}                    }                }            } catch (FileNotFoundException e) {                e.printStackTrace();            } catch (Exception e) {                e.printStackTrace();            } finally {                if (br != null) {                    try {                        br.close();                    } catch (Exception e) {                        e.printStackTrace();                    }                }            }        }        return success;    }    public static void classifier_RTrees_4class_fromxml(final Mat frame, final Mat saving_mask, final Context context) {        //Imgcodecs.imwrite(AppResultReceiver.ROOT_FOLDER_PATH + "/classified_mask.png", saving_mask);        //Imgcodecs.imwrite(AppResultReceiver.ROOT_FOLDER_PATH + "/classified_image.png", frame);        int build = 201812;        int kClass = 4;        int features = 5;        switch (build) {            case 201812:                features = 5;            default:                break;        }        RTrees classier = null;        if (rtreesClassier == null)            rtreesClassier = RTrees.load(AppResultReceiver.ROOT_FOLDER_PATH + "/" + modelFileName + "_rtrees.xml");        classier = rtreesClassier;        if (classier != null && saving_mask != null && saving_mask.width() > 0) {            //find the nearest neighbours of test data            Mat results = new Mat();            Mat neighborResponses = new Mat();            Mat dists = new Mat();            int[] predictedLabel = new int[kClass];            for (int i = 0; i < kClass; i++) predictedLabel[i] = 0;            int pixel_count = 0;            int i, j;            for (i = 0; i < frame.rows(); i++) {                for (j = 0; j < frame.cols(); j++) {                    if (saving_mask.get(i, j)[0] == 0)                        continue;//                double dataHSV[] = frame.get(i, j);                    double dataBGR[] = frame.get(i, j);//prepare test data                    Mat testData = new Mat(1, features, CvType.CV_32FC1, new Scalar(1));                    float[] hsv = rgb2hsv((int) dataBGR[2], (int) dataBGR[1], (int) dataBGR[0]);                    int[] ycbcr = rgb2ycbcr((int) dataBGR[2], (int) dataBGR[1], (int) dataBGR[0]);                    int[] lab = rgb2lab((int) dataBGR[2], (int) dataBGR[1], (int) dataBGR[0]);                    switch (build) {                        case 201812:                            // R/G, G/B, R/B                            testData.put(0, 0, (double) (dataBGR[2] + 1) / (double) (dataBGR[1] + 1));                            testData.put(0, 1, (double) (dataBGR[1] + 1) / (double) (dataBGR[0] + 1));                            testData.put(0, 2, (double) (dataBGR[2] + 1) / (double) (dataBGR[0] + 1));                            testData.put(0, 3, (double) hsv[0]);                            testData.put(0, 4, (double) ycbcr[0]);                        default:                            break;                    }                    float p = classier.predict(testData, results, 0);                    testData.release();                    int result = Integer.valueOf(results.dump().replace("[", "").replace("]", ""));                    pixel_count++;                    switch (result) {                        case 0:                            predictedLabel[0]++;                            break;                        case 1:                            predictedLabel[1]++;                            break;                        case 2:                            predictedLabel[2]++;                            break;                        case 3:                            predictedLabel[3]++;                            break;                        case 4:                            predictedLabel[4]++;                            break;                        case 5:                            predictedLabel[5]++;                            break;                        case 6:                            predictedLabel[6]++;                            break;                        case 7:                            predictedLabel[7]++;                            break;                        default:                            break;                    }                }            }            List<String> title = new ArrayList<String>();            title.add("上:");            title.add("芽:");            title.add("腐:");            title.add("焦:");//        Epithelial 嫩皮//        Granulation 芽//        Sloughy 腐//        Necrosis 焦//        Exudate 滲//        Maceration 浸//        Swelling 腫            TissueAnalysisResult.clear();            List<String> result1 = new ArrayList<String>();            int value1 = Math.round(100 * (float) predictedLabel[0] / pixel_count);            result1.add(title.get(0));            result1.add(Integer.toString(value1) + "%");            TissueAnalysisResult.add(result1);            List<String> result2 = new ArrayList<String>();            int value2 = Math.round(100 * (float) (predictedLabel[1]) / pixel_count);            result2.add(title.get(1));            result2.add(Integer.toString(value2) + "%");            TissueAnalysisResult.add(result2);            List<String> result3 = new ArrayList<String>();            int value3 = Math.round(100 * (float) (predictedLabel[2]) / pixel_count);            result3.add(title.get(2));            result3.add(Integer.toString(value3) + "%");            TissueAnalysisResult.add(result3);            List<String> result4 = new ArrayList<String>();            int value4 = Math.round(100 * (float) (predictedLabel[3]) / pixel_count);            if ((value1 + value2 + value3 + value4) > 100 || (value1 + value2 + value3 + value4) < 100)                value4 = 100 - value1 - value2 - value3;            result4.add(title.get(3));            result4.add(Integer.toString(value4) + "%");            TissueAnalysisResult.add(result4);        }    }    public static boolean classifier_Knn_4class_build(final Context context) {        int build = 201812;        int kClass = 4;        int features = 5;        int maxN = 277849;        switch (build) {            case 201812:                features = 5;            default:                break;        }        //prepare trainData and trainLabel        Mat trainingData = new Mat(maxN, features, CvType.CV_32FC1, new Scalar(1));        Mat trainingLabel = new Mat(maxN, 1, CvType.CV_32SC1, new Scalar(1));        BufferedReader br = null;        String line = "";        String cvsSplitBy = ",";        int samplingN = -1;        try {            AssetManager assetManager = context.getAssets();            InputStream inputStream = assetManager.open("mldata/" + modelFileName + ".csv");            br = new BufferedReader(new InputStreamReader(inputStream));            while ((line = br.readLine()) != null) {                line = line.trim();                if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {                } else {                    // use comma as separator                    String[] data = line.split(cvsSplitBy);                    samplingN++;                    float[] hsv = rgb2hsv(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                    int[] ycbcr = rgb2ycbcr(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                    int[] lab = rgb2lab(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                    switch (build) {                        case 201812:                            // R/G, G/B, R/B                            trainingData.put(samplingN, 0, (double) (Double.parseDouble(data[1] + 1) / (double) Double.parseDouble(data[2] + 1)));                            trainingData.put(samplingN, 1, (double) (Double.parseDouble(data[2] + 1) / (double) Double.parseDouble(data[3] + 1)));                            trainingData.put(samplingN, 2, (double) (Double.parseDouble(data[1] + 1) / (double) Double.parseDouble(data[3] + 1)));                            trainingData.put(samplingN, 3, (double) hsv[0]);                            trainingData.put(samplingN, 4, (double) ycbcr[0]);                        default:                            break;                    }                    trainingLabel.put(samplingN, 0, Double.parseDouble(data[0]));                }                if (samplingN >= maxN)                    break;            }        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (Exception e) {            e.printStackTrace();        } finally {            if (br != null) {                try {                    br.close();                } catch (Exception e) {                    e.printStackTrace();                }            }        }        trainingData = trainingData.submat(0, samplingN, 0, features);        trainingLabel = trainingLabel.submat(0, samplingN, 0, 1);        TrainData td = TrainData.create(trainingData, Ml.ROW_SAMPLE, trainingLabel);        //train data        KNearest classier = KNearest.create();        boolean success = classier.train(td.getSamples(), Ml.ROW_SAMPLE, td.getResponses());        if (success) {            try {                classier.save(AppResultReceiver.ROOT_FOLDER_PATH + "/" + modelFileName + "_knn.xml");            } catch (Exception e) {                e.printStackTrace();                success = false;            }        }        boolean printout = false;        if (printout) {            try {                AssetManager assetManager = context.getAssets();                InputStream inputStream = assetManager.open(modelFileName + ".csv");                br = new BufferedReader(new InputStreamReader(inputStream));                while ((line = br.readLine()) != null) {                    line = line.trim();                    if (line.startsWith("/") || line.startsWith("\r") || line.startsWith("\n") || line.equals("") || line.startsWith("#")) {                    } else {                        // use comma as separator                        String[] data = line.split(cvsSplitBy);                        Mat testData = new Mat(1, features, CvType.CV_32FC1, new Scalar(1));                        float[] hsv = rgb2hsv(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                        int[] ycbcr = rgb2ycbcr(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                        int[] lab = rgb2lab(Integer.valueOf(data[1]), Integer.valueOf(data[2]), Integer.valueOf(data[3]));                        switch (build) {                            case 201812:                                // R/G, G/B, R/B                                testData.put(0, 0, (double) (Double.parseDouble(data[1] + 1) / (double) Double.parseDouble(data[2] + 1)));                                testData.put(0, 1, (double) (Double.parseDouble(data[2] + 1) / (double) Double.parseDouble(data[3] + 1)));                                testData.put(0, 2, (double) (Double.parseDouble(data[1] + 1) / (double) Double.parseDouble(data[3] + 1)));                                testData.put(0, 3, (double) hsv[0]);                                testData.put(0, 4, (double) ycbcr[0]);                            default:                                break;                        }                        Mat results = new Mat();                        float p = classier.findNearest(testData, 1, results);                        testData.release();                        int result = Integer.valueOf(results.dump().replace("[", "").replace("]", ""));                        //if (result != Integer.valueOf(data[0])) {                        Log.d("TissueClassification", "prd error: " + data[0] + " to " + result + " from " + data[1] + "," + data[2] + "," + data[3] + "," + hsv[0] + "," + ycbcr[0]);                        //}                    }                }            } catch (FileNotFoundException e) {                e.printStackTrace();            } catch (Exception e) {                e.printStackTrace();            } finally {                if (br != null) {                    try {                        br.close();                    } catch (Exception e) {                        e.printStackTrace();                    }                }            }        }        return success;    }    public static void classifier_Knn_4class_fromxml(final Mat frame, final Mat saving_mask, final Context context) {        //Imgcodecs.imwrite(AppResultReceiver.ROOT_FOLDER_PATH + "/classified_mask.png", saving_mask);        //Imgcodecs.imwrite(AppResultReceiver.ROOT_FOLDER_PATH + "/classified_image.png", frame);        int build = 201812;        int kClass = 4;        int features = 5;        switch (build) {            case 201812:                features = 5;            default:                break;        }        KNearest classier = null;        if (knearestClassier == null)            knearestClassier = KNearest.load(AppResultReceiver.ROOT_FOLDER_PATH + "/" + modelFileName + "_knn.xml");        classier = knearestClassier;        if (classier != null && saving_mask != null && saving_mask.width() > 0) {            //find the nearest neighbours of test data            Mat results = new Mat();            Mat neighborResponses = new Mat();            Mat dists = new Mat();            int[] predictedLabel = new int[kClass];            for (int i = 0; i < kClass; i++) predictedLabel[i] = 0;            int pixel_count = 0;            int i, j;            for (i = 0; i < frame.rows(); i++) {                for (j = 0; j < frame.cols(); j++) {                    if (saving_mask.get(i, j)[0] == 0)                        continue;//                double dataHSV[] = frame.get(i, j);                    double dataBGR[] = frame.get(i, j);//prepare test data                    Mat testData = new Mat(1, features, CvType.CV_32FC1, new Scalar(1));                    float[] hsv = rgb2hsv((int) dataBGR[2], (int) dataBGR[1], (int) dataBGR[0]);                    int[] ycbcr = rgb2ycbcr((int) dataBGR[2], (int) dataBGR[1], (int) dataBGR[0]);                    int[] lab = rgb2lab((int) dataBGR[2], (int) dataBGR[1], (int) dataBGR[0]);                    switch (build) {                        case 201812:                            // R/G, G/B, R/B                            testData.put(0, 0, (double) (dataBGR[2] + 1) / (double) (dataBGR[1] + 1));                            testData.put(0, 1, (double) (dataBGR[1] + 1) / (double) (dataBGR[0] + 1));                            testData.put(0, 2, (double) (dataBGR[2] + 1) / (double) (dataBGR[0] + 1));                            testData.put(0, 3, (double) hsv[0]);                            testData.put(0, 4, (double) ycbcr[0]);                        default:                            break;                    }                    float p = classier.findNearest(testData, 1, results);                    testData.release();                    int result = Integer.valueOf(results.dump().replace("[", "").replace("]", ""));                    pixel_count++;                    switch (result) {                        case 0:                            predictedLabel[0]++;                            break;                        case 1:                            predictedLabel[1]++;                            break;                        case 2:                            predictedLabel[2]++;                            break;                        case 3:                            predictedLabel[3]++;                            break;                        case 4:                            predictedLabel[4]++;                            break;                        case 5:                            predictedLabel[5]++;                            break;                        case 6:                            predictedLabel[6]++;                            break;                        case 7:                            predictedLabel[7]++;                            break;                        default:                            break;                    }                }            }            List<String> title = new ArrayList<String>();            title.add("上:");            title.add("芽:");            title.add("腐:");            title.add("焦:");//        Epithelial 嫩皮//        Granulation 芽//        Sloughy 腐//        Necrosis 焦//        Exudate 滲//        Maceration 浸//        Swelling 腫            TissueAnalysisResult.clear();            List<String> result1 = new ArrayList<String>();            int value1 = Math.round(100 * (float) predictedLabel[0] / pixel_count);            result1.add(title.get(0));            result1.add(Integer.toString(value1) + "%");            TissueAnalysisResult.add(result1);            List<String> result2 = new ArrayList<String>();            int value2 = Math.round(100 * (float) (predictedLabel[1]) / pixel_count);            result2.add(title.get(1));            result2.add(Integer.toString(value2) + "%");            TissueAnalysisResult.add(result2);            List<String> result3 = new ArrayList<String>();            int value3 = Math.round(100 * (float) (predictedLabel[2]) / pixel_count);            result3.add(title.get(2));            result3.add(Integer.toString(value3) + "%");            TissueAnalysisResult.add(result3);            List<String> result4 = new ArrayList<String>();            int value4 = Math.round(100 * (float) (predictedLabel[3]) / pixel_count);            if ((value1 + value2 + value3 + value4) > 100 || (value1 + value2 + value3 + value4) < 100)                value4 = 100 - value1 - value2 - value3;            result4.add(title.get(3));            result4.add(Integer.toString(value4) + "%");            TissueAnalysisResult.add(result4);        }    }    public static void testML() {        //System.loadLibrary(Core.NATIVE_LIBRARY_NAME);        // 训练数据，两个维度，表示身高和体重        float[] trainingData = {186, 80, 185, 81, 160, 50, 161, 48};        // 训练标签数据，前两个表示男生0，后两个表示女生1,由于使用了多种机器学习算法，他们的输入有些不一样，所以labelsMat有三种        float[] labels = {0f, 0f, 0f, 0f, 1f, 1f, 1f, 1f};        int[] labels2 = {0, 0, 1, 1};        float[] labels3 = {0, 0, 1, 1};        // 测试数据,先男后女        float[] test = {184, 79, 159, 50};        Mat trainingDataMat = new Mat(4, 2, CvType.CV_32FC1);        trainingDataMat.put(0, 0, trainingData);        Mat labelsMat = new Mat(4, 2, CvType.CV_32FC1);        labelsMat.put(0, 0, labels);        Mat labelsMat2 = new Mat(4, 1, CvType.CV_32SC1);        labelsMat2.put(0, 0, labels2);        Mat labelsMat3 = new Mat(4, 1, CvType.CV_32FC1);        labelsMat3.put(0, 0, labels3);        Mat sampleMat = new Mat(2, 2, CvType.CV_32FC1);        sampleMat.put(0, 0, test);        //sampleMat.put(0, 0, test);//        MyAnn(trainingDataMat, labelsMat, sampleMat);//        MyBoost(trainingDataMat, labelsMat2, sampleMat);        MyDtrees(trainingDataMat, labelsMat2, sampleMat);//        MyKnn(trainingDataMat, labelsMat3, sampleMat);//        MyLogisticRegression(trainingDataMat, labelsMat3, sampleMat);//        MyNormalBayes(trainingDataMat, labelsMat2, sampleMat);//        MyRTrees(trainingDataMat, labelsMat2, sampleMat);        MySvm(trainingDataMat, labelsMat2, sampleMat);//        MySvmsgd(trainingDataMat, labelsMat2, sampleMat);    }    // 决策树    public static Mat MyDtrees(Mat trainingData, Mat labels, Mat testData) {        DTrees dtree = DTrees.create(); // 创建分类器        dtree.setMaxDepth(8); // 设置最大深度        dtree.setMinSampleCount(2);        dtree.setUseSurrogates(false);        dtree.setCVFolds(0); // 交叉验证        dtree.setUse1SERule(false);        dtree.setTruncatePrunedTree(false);        TrainData td = TrainData.create(trainingData, Ml.ROW_SAMPLE, labels);        boolean success = dtree.train(td.getSamples(), Ml.ROW_SAMPLE, td.getResponses());        System.out.println("Dtrees training result: " + success);        dtree.save(AppResultReceiver.ROOT_FOLDER_PATH + "/MyDtrees.xml");//存储模型        Mat responseMat = new Mat();        float response = dtree.predict(testData, responseMat, 0);        System.out.println("Dtrees responseMat:\n" + responseMat.dump());//        for (int i = 0; i < responseMat.height(); i++) {//            if (responseMat.get(i, 0)[0] == 0)//                System.out.println("Boy\n");//            if (responseMat.get(i, 0)[0] == 1)//                System.out.println("Girl\n");//        }        return responseMat;    }    // 支持向量机    public static Mat MySvm(Mat trainingData, Mat labels, Mat testData) {        SVM svm = SVM.create();        svm.setKernel(SVM.RBF);        svm.setType(SVM.C_SVC);        TermCriteria criteria = new TermCriteria(TermCriteria.EPS + TermCriteria.MAX_ITER, 1000, 0);        svm.setTermCriteria(criteria);        svm.setGamma(0.5);        svm.setNu(0.5);        svm.setC(1);        TrainData td = TrainData.create(trainingData, Ml.ROW_SAMPLE, labels);        boolean success = svm.train(td.getSamples(), Ml.ROW_SAMPLE, td.getResponses());        System.out.println("Svm training result: " + success);        svm.save(AppResultReceiver.ROOT_FOLDER_PATH + "/MySvm.xml");//存储模型        // svm.save("D:/bp.xml");//存储模型        // svm.load("D:/bp.xml");//读取模型        Mat responseMat = new Mat();        svm.predict(testData, responseMat, 0);        System.out.println("SVM responseMat:\n" + responseMat.dump());//        for (int i = 0; i < responseMat.height(); i++) {//            if (responseMat.get(i, 0)[0] == 0)//                System.out.println("Boy\n");//            if (responseMat.get(i, 0)[0] == 1)//                System.out.println("Girl\n");//        }        return responseMat;    }    // 人工神经网络    public static Mat MyAnn(Mat trainingData, Mat labels, Mat testData) {        // train data using aNN        TrainData td = TrainData.create(trainingData, Ml.ROW_SAMPLE, labels);        Mat layerSizes = new Mat(1, 4, CvType.CV_32FC1);        // 含有两个隐含层的网络结构，输入、输出层各两个节点，每个隐含层含两个节点        layerSizes.put(0, 0, new float[]{2, 2, 2, 2});        ANN_MLP ann = ANN_MLP.create();        ann.setLayerSizes(layerSizes);        ann.setTrainMethod(ANN_MLP.BACKPROP);        ann.setBackpropWeightScale(0.1);        ann.setBackpropMomentumScale(0.1);        ann.setActivationFunction(ANN_MLP.SIGMOID_SYM, 1, 1);        ann.setTermCriteria(new TermCriteria(TermCriteria.MAX_ITER + TermCriteria.EPS, 300, 0.0));        boolean success = ann.train(td.getSamples(), Ml.ROW_SAMPLE, td.getResponses());        System.out.println("Ann training result: " + success);        // ann.save("D:/bp.xml");//存储模型        // ann.load("D:/bp.xml");//读取模型        // 测试数据        Mat responseMat = new Mat();        ann.predict(testData, responseMat, 0);        System.out.println("Ann responseMat:\n" + responseMat.dump());        for (int i = 0; i < responseMat.size().height; i++) {            if (responseMat.get(i, 0)[0] + responseMat.get(i, i)[0] >= 1)                System.out.println("Girl\n");            if (responseMat.get(i, 0)[0] + responseMat.get(i, i)[0] < 1)                System.out.println("Boy\n");        }        return responseMat;    }    // Boost    public static Mat MyBoost(Mat trainingData, Mat labels, Mat testData) {        Boost boost = Boost.create();        // boost.setBoostType(Boost.DISCRETE);        boost.setBoostType(Boost.GENTLE);        boost.setWeakCount(2);        boost.setWeightTrimRate(0.95);        boost.setMaxDepth(2);        boost.setUseSurrogates(false);        boost.setPriors(new Mat());        TrainData td = TrainData.create(trainingData, Ml.ROW_SAMPLE, labels);        boolean success = boost.train(td.getSamples(), Ml.ROW_SAMPLE, td.getResponses());        System.out.println("Boost training result: " + success);        // boost.save("D:/bp.xml");//存储模型        Mat responseMat = new Mat();        float response = boost.predict(testData, responseMat, 0);        System.out.println("Boost responseMat:\n" + responseMat.dump());        for (int i = 0; i < responseMat.height(); i++) {            if (responseMat.get(i, 0)[0] == 0)                System.out.println("Boy\n");            if (responseMat.get(i, 0)[0] == 1)                System.out.println("Girl\n");        }        return responseMat;    }    // K最邻近    public static Mat MyKnn(Mat trainingData, Mat labels, Mat testData) {        final int K = 2;        TrainData td = TrainData.create(trainingData, Ml.ROW_SAMPLE, labels);        KNearest knn = KNearest.create();        boolean success = knn.train(trainingData, Ml.ROW_SAMPLE, labels);        System.out.println("Knn training result: " + success);        // knn.save("D:/bp.xml");//存储模型        // find the nearest neighbours of test data        Mat results = new Mat();        Mat neighborResponses = new Mat();        Mat dists = new Mat();        knn.findNearest(testData, K, results, neighborResponses, dists);        System.out.println("results:\n" + results.dump());        System.out.println("Knn neighborResponses:\n" + neighborResponses.dump());        System.out.println("dists:\n" + dists.dump());        for (int i = 0; i < results.height(); i++) {            if (results.get(i, 0)[0] == 0)                System.out.println("Boy\n");            if (results.get(i, 0)[0] == 1)                System.out.println("Girl\n");        }        return results;    }    // 逻辑回归    public static Mat MyLogisticRegression(Mat trainingData, Mat labels, Mat testData) {        LogisticRegression lr = LogisticRegression.create();        TrainData td = TrainData.create(trainingData, Ml.ROW_SAMPLE, labels);        boolean success = lr.train(td.getSamples(), Ml.ROW_SAMPLE, td.getResponses());        System.out.println("LogisticRegression training result: " + success);        // lr.save("D:/bp.xml");//存储模型        Mat responseMat = new Mat();        float response = lr.predict(testData, responseMat, 0);        System.out.println("LogisticRegression responseMat:\n" + responseMat.dump());        for (int i = 0; i < responseMat.height(); i++) {            if (responseMat.get(i, 0)[0] == 0)                System.out.println("Boy\n");            if (responseMat.get(i, 0)[0] == 1)                System.out.println("Girl\n");        }        return responseMat;    }    // 贝叶斯    public static Mat MyNormalBayes(Mat trainingData, Mat labels, Mat testData) {        NormalBayesClassifier nb = NormalBayesClassifier.create();        TrainData td = TrainData.create(trainingData, Ml.ROW_SAMPLE, labels);        boolean success = nb.train(td.getSamples(), Ml.ROW_SAMPLE, td.getResponses());        System.out.println("NormalBayes training result: " + success);        // nb.save("D:/bp.xml");//存储模型        Mat responseMat = new Mat();        float response = nb.predict(testData, responseMat, 0);        System.out.println("NormalBayes responseMat:\n" + responseMat.dump());        for (int i = 0; i < responseMat.height(); i++) {            if (responseMat.get(i, 0)[0] == 0)                System.out.println("Boy\n");            if (responseMat.get(i, 0)[0] == 1)                System.out.println("Girl\n");        }        return responseMat;    }    // 随机森林    public static Mat MyRTrees(Mat trainingData, Mat labels, Mat testData) {        RTrees rtrees = RTrees.create();        rtrees.setMaxDepth(4);        rtrees.setMinSampleCount(2);        rtrees.setRegressionAccuracy(0.f);        rtrees.setUseSurrogates(false);        rtrees.setMaxCategories(16);        rtrees.setPriors(new Mat());        rtrees.setCalculateVarImportance(false);        rtrees.setActiveVarCount(1);        rtrees.setTermCriteria(new TermCriteria(TermCriteria.MAX_ITER, 5, 0));        TrainData tData = TrainData.create(trainingData, Ml.ROW_SAMPLE, labels);        boolean success = rtrees.train(tData.getSamples(), Ml.ROW_SAMPLE, tData.getResponses());        System.out.println("Rtrees training result: " + success);        // rtrees.save("D:/bp.xml");//存储模型        Mat responseMat = new Mat();        rtrees.predict(testData, responseMat, 0);        System.out.println("Rtrees responseMat:\n" + responseMat.dump());        for (int i = 0; i < responseMat.height(); i++) {            if (responseMat.get(i, 0)[0] == 0)                System.out.println("Boy\n");            if (responseMat.get(i, 0)[0] == 1)                System.out.println("Girl\n");        }        return responseMat;    }    // SGD支持向量机    public static Mat MySvmsgd(Mat trainingData, Mat labels, Mat testData) {        SVMSGD Svmsgd = SVMSGD.create();        TermCriteria criteria = new TermCriteria(TermCriteria.EPS + TermCriteria.MAX_ITER, 1000, 0);        Svmsgd.setTermCriteria(criteria);        Svmsgd.setInitialStepSize(2);        Svmsgd.setSvmsgdType(SVMSGD.SGD);        Svmsgd.setMarginRegularization(0.5f);        boolean success = Svmsgd.train(trainingData, Ml.ROW_SAMPLE, labels);        System.out.println("SVMSGD training result: " + success);        // svm.save("D:/bp.xml");//存储模型        // svm.load("D:/bp.xml");//读取模型        Mat responseMat = new Mat();        Svmsgd.predict(testData, responseMat, 0);        System.out.println("SVMSGD responseMat:\n" + responseMat.dump());        for (int i = 0; i < responseMat.height(); i++) {            if (responseMat.get(i, 0)[0] == 0)                System.out.println("Boy\n");            if (responseMat.get(i, 0)[0] == 1)                System.out.println("Girl\n");        }        return responseMat;    }    public static boolean classifier_svm_wound_build(final Context context) {        int features = 3;        int maxN = 1800000;        //prepare trainData and trainLabel        Mat trainingDatas = new Mat(maxN, features, CvType.CV_32FC1, new Scalar(0));        Mat trainingLabels = new Mat(maxN, 1, CvType.CV_32SC1, new Scalar(0));//        Mat resultCBCR = new Mat(255, 255, CvType.CV_8UC1, Scalar.all(0));//        Mat resultLAB = new Mat(255, 255, CvType.CV_8UC1, Scalar.all(0));//        Mat resultBGR = new Mat(255, 255, CvType.CV_8UC1, Scalar.all(0));//        int[] resultHSV = new int[255];        String dataset_path = AppResultReceiver.ROOT_FOLDER_PATH + "/dataset/";        File root = new File(dataset_path + "image/");        File[] list = root.listFiles();        int count = 0;        int samplingN = 0;        for (File f : list) {            if (f.isDirectory()) {            } else {                try {                    Mat src = null;                    if (!AppResultReceiver.dataEncrypt)                        src = Imgcodecs.imread(f.getAbsoluteFile().getPath());                    else                        src = FileHelper.imreadSecret(f.getAbsoluteFile().getPath());                    if (src == null || src.empty())                        continue;                    org.opencv.core.Size sz0 = new org.opencv.core.Size(src.cols() / 20, src.rows() / 20);                    Imgproc.resize(src.clone(), src, sz0);                    System.out.println(count++ + "/" + root.listFiles().length                            + " " + f.getAbsoluteFile().getPath());                    Mat ycbcr = new Mat();//                    Mat lab = new Mat();                    Mat hsv = new Mat();                    Imgproc.cvtColor(src, ycbcr, Imgproc.COLOR_BGR2YCrCb);//                    Imgproc.cvtColor(src, lab, Imgproc.COLOR_BGR2Lab);                    Imgproc.cvtColor(src, hsv, Imgproc.COLOR_BGR2HSV);                    Mat mask = null;                    if (!AppResultReceiver.dataEncrypt)                        mask = Imgcodecs.imread(dataset_path + "kernel/" + f.getAbsoluteFile().getName());                    else                        mask = FileHelper.imreadSecret(dataset_path + "kernel/" + f.getAbsoluteFile().getName());                    if (src != null && mask != null && !src.empty()                            && !mask.empty()) {                        if (mask.cols() != src.cols()                                || mask.rows() != src.rows()) {                            org.opencv.core.Size sz = new org.opencv.core.Size(src.cols(), src.rows());                            Imgproc.resize(mask.clone(), mask, sz);                        }                        //Highgui.imwrite(dataset_path + count+".png", mask);                        int nr = src.rows(); // number of rows                        int nc = src.cols(); // number of columns                        for (int y = 0; y < nr; y++) {                            for (int x = 0; x < nc; x++) {//                                double[] data_bgr = src.get(y, x);                                double[] data_mask = mask.get(y, x);                                double[] data_ycbcr = ycbcr.get(y, x);//                                double[] data_lab = lab.get(y, x);                                double[] data_hsv = hsv.get(y, x);                                if (data_mask[0] >= 253 && data_mask[1] <= 37                                        && data_mask[2] <= 5) {                                    trainingDatas.put(samplingN, 0,                                            (double) data_ycbcr[1]);                                    trainingDatas.put(samplingN, 1,                                            (double) data_ycbcr[2]);                                    trainingDatas.put(samplingN, 2,                                            (double) data_hsv[0]);                                    trainingLabels.put(samplingN, 0, 1);                                    samplingN++;//                                    resultCBCR.put((int) data_ycbcr[1],//                                            (int) data_ycbcr[2], 255, 255, 255);//                                    resultLAB.put((int) data_lab[1],//                                            (int) data_lab[2], 255, 255, 255);//                                    resultBGR.put((int) data_bgr[1],//                                            (int) data_bgr[2], 255, 255, 255);//                                    resultHSV[(int) data_hsv[0]]++;                                } else {                                    trainingDatas.put(samplingN, 0,                                            (double) data_ycbcr[1]);                                    trainingDatas.put(samplingN, 1,                                            (double) data_ycbcr[2]);                                    trainingDatas.put(samplingN, 2,                                            (double) data_hsv[0]);                                    trainingLabels.put(samplingN, 0, 0);                                    samplingN++;                                }                            } // end of row                        }                    } // if (src != null                    ycbcr.release();                    ycbcr = null;//                    lab.release();//                    lab = null;                    hsv.release();                    hsv = null;                    src.release();                    src = null;                    mask.release();                    mask = null;                    System.gc();                } catch (Exception e) {                }            } // if (f.isDirectory()) {            try {                Thread.sleep(1);            } catch (Exception e) {            }        } // for (File f : list)//        Imgcodecs.imwrite(dataset_path + "bgr.png", resultBGR);//        Imgcodecs.imwrite(dataset_path + "cbcr.png", resultCBCR);//        Imgcodecs.imwrite(dataset_path + "lab.png", resultLAB);////        String msg = "";//        for (int i = 0; i < 255; i++)//            msg = msg + "\n" + resultHSV[i];////        BufferedWriter writer = null;//        try {//            File textFile = new File(dataset_path + "hsv.csv");//            writer = new BufferedWriter(new java.io.FileWriter(textFile, false));//            writer.write(msg);//            writer.flush();//        } catch (Exception e) {//        } finally {//            try {//                // Close the writer regardless of what happens...//                writer.close();//            } catch (Exception e) {//            }//        }        trainingDatas = trainingDatas.submat(0, samplingN, 0, features);        trainingLabels = trainingLabels.submat(0, samplingN, 0, 1);        SVM classier = SVM.create();        classier.setKernel(SVM.RBF);        classier.setType(SVM.C_SVC);        //TermCriteria criteria = new TermCriteria(TermCriteria.EPS + TermCriteria.MAX_ITER, 1000, 1e-6);        //classier.setTermCriteria(criteria);        //classier.setGamma(0.0001);        //classier.setNu(0.5);        //classier.setC(100);        //boolean success = classier.trainAuto(td.getSamples(), Ml.ROW_SAMPLE, td.getResponses());        //boolean success = classier.train(trainingData, Ml.ROW_SAMPLE, trainingLabel);        boolean success = classier.trainAuto(trainingDatas, Ml.ROW_SAMPLE, trainingLabels);        if (success) {            try {                classier.save(AppResultReceiver.ROOT_FOLDER_PATH + "/woundcolor_svm.xml");            } catch (Exception e) {                e.printStackTrace();                success = false;            }        }        if (validationPrintOut || true) {            try {                Mat responseMat = new Mat();                float response = classier.predict(trainingDatas, responseMat, 0);                //System.out.println("SVM responseMat:\n" + responseMat.dump());                int error = 0;                int correct = 0;                for (int i = 0; i < responseMat.height(); i++) {                    if (responseMat.get(i, 0)[0] == trainingLabels.get(i, 0)[0]) {                        correct++;                        //Log.d("TissueClassification", "predict: " + trainingLabel.get(i,0)[0] + " to " + responseMat.get(i, 0)[0] + " from " + trainingData.get(i, 0)[0] + "," + trainingData.get(i, 1)[0] + "," + trainingData.get(i, 2)[0]);                    } else {                        error++;                        Log.d("TissueClassification", "predict: (" + i + ")" + trainingLabels.get(i, 0)[0] + " to " + responseMat.get(i, 0)[0] + " from " + trainingDatas.get(i, 0)[0] + "," + trainingDatas.get(i, 1)[0] + "," + trainingDatas.get(i, 2)[0]);                    }                }                Log.d("TissueClassification", "accuracy: " + (double) correct / (double) (correct + error));            } catch (Exception e) {                e.printStackTrace();            } finally {            }        }        return success;    }    public static int classifier_svm_wound_fromxml(final Mat img_color, Mat maskc, final Context context) {        int wound_tissue_count = 0;        int features = 3;//        SVM classier = null;        DTrees classier = null;//        try {//            // load  file from application resources//            File mModelDir = context.getDir("mldata", Context.MODE_PRIVATE);//            File mModel = new File(mModelDir, "woundcolor_dtree1.xml");//            mModelDir.delete();////            classier = SVM.load(mModel.getAbsolutePath());//            classier = DTrees.load(mModel.getAbsolutePath());////        } catch (Exception e) {        try {            // load  file from application resources            File mModelDir = context.getDir("", Context.MODE_PRIVATE);            File mModel = new File(mModelDir, "woundcolor_dtree.xml");            if (!mModel.canRead()) {                InputStream is = context.getAssets().open("mldata/woundcolor_dtree.xml");                FileOutputStream os = new FileOutputStream(mModel);                byte[] buffer = new byte[8192];                int bytesRead;                while ((bytesRead = is.read(buffer)) != -1) {                    os.write(buffer, 0, bytesRead);                }                is.close();                os.close();            }////                classier = SVM.load(mModel.getAbsolutePath());            classier = DTrees.load(mModel.getAbsolutePath());            //mModelDir.delete();        } catch (Exception ex) {            ex.printStackTrace();            Log.e(TAG, "Failed to load cascade. Exception thrown: " + ex);        }//        }        if (classier != null && maskc != null && maskc.width() > 0) {            String Main_DIR = AppResultReceiver.PROJECT_NAME;            File file5 = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS), Main_DIR);            //find the nearest neighbours of test data            Mat img_xyz = new Mat();            Imgproc.cvtColor(img_color, img_xyz, Imgproc.COLOR_BGR2Lab);            Mat img_hsv = new Mat();            Imgproc.cvtColor(img_color, img_hsv, Imgproc.COLOR_BGR2HSV);//            Imgcodecs.imwrite(file5.getAbsolutePath() + "/img_bgr.png", img_color);//            Imgcodecs.imwrite(file5.getAbsolutePath() + "/img_xyz.png", img_xyz);//            Imgcodecs.imwrite(file5.getAbsolutePath() + "/img_hsv.png", img_hsv);            Mat testData = new Mat(1, features, CvType.CV_32FC1, new Scalar(0.0));            int nr = img_color.rows(); // number of rows            int nc = img_color.cols(); // number of columns            int x, y;            float response;            for (y = 0; y < nr; y++) {                for (x = 0; x < nc; x++) {                    double[] data_xyz = img_xyz.get(y, x);                    double[] data_hsv = img_hsv.get(y, x);                    testData.put(0, 0, (double) data_xyz[1]);                    testData.put(0, 1, (double) data_xyz[2]);                    testData.put(0, 2, (double) data_hsv[0]);                    response = classier.predict(testData);                    if (response == 1.0) {                        maskc.put(y, x, Imgproc.GC_PR_FGD);                        wound_tissue_count++;                    }                } // end of row            }            //Imgcodecs.imwrite(file5.getAbsolutePath() + "/img_mask1.png", maskc);            //imgc.release();            img_hsv.release();            img_xyz.release();        }        return wound_tissue_count;    }    public static int countNonZero_replaceToOne(final Mat img_gray) {        int wound_tissue_count = 0;        int nr = img_gray.rows(); // number of rows        int nc = img_gray.cols(); // number of columns        int x, y;        for (y = 0; y < nr; y++) {            for (x = 0; x < nc; x++) {                double[] data_xyz = img_gray.get(y, x);                if (data_xyz[0] > 2.0) {                    img_gray.put(y, x, 1);                    wound_tissue_count++;                }            } // end of row        }        return wound_tissue_count;    }}